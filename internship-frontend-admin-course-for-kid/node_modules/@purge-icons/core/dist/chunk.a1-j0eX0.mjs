// src/types.ts

// src/utils.ts
import Debug from "debug";
const debug = Debug("purge-icons");

// src/generated/collections.ts
const CollectionIds = [
  "mdi",
  "mdi-light",
  "ic",
  "uil",
  "uim",
  "bx",
  "ri",
  "la",
  "jam",
  "ion",
  "bi",
  "clarity",
  "carbon",
  "cil",
  "gg",
  "tabler",
  "fa-solid",
  "fa-regular",
  "vaadin",
  "icomoon-free",
  "eva",
  "dashicons",
  "entypo",
  "zondicons",
  "flat-color-icons",
  "octicon",
  "codicon",
  "ant-design",
  "feather",
  "fe",
  "system-uicons",
  "gridicons",
  "heroicons-outline",
  "heroicons-solid",
  "ps",
  "el",
  "foundation",
  "typcn",
  "subway",
  "raphael",
  "icons8",
  "wpf",
  "iwwa",
  "topcoat",
  "ei",
  "bytesize",
  "maki",
  "oi",
  "et",
  "fa",
  "zmdi",
  "whh",
  "si-glyph",
  "ls",
  "simple-line-icons",
  "flat-ui",
  "vs",
  "websymbol",
  "il",
  "bpmn",
  "fontelico",
  "noto",
  "noto-v1",
  "twemoji",
  "openmoji",
  "emojione",
  "emojione-monotone",
  "emojione-v1",
  "fxemoji",
  "logos",
  "cib",
  "simple-icons",
  "fa-brands",
  "brandico",
  "entypo-social",
  "cryptocurrency",
  "map",
  "geo",
  "cif",
  "wi",
  "medical-icon"
];
const ExtractorRegex = /(?:mdi|mdi-light|ic|uil|uim|bx|ri|la|jam|ion|bi|clarity|carbon|cil|gg|tabler|fa-solid|fa-regular|vaadin|icomoon-free|eva|dashicons|entypo|zondicons|flat-color-icons|octicon|codicon|ant-design|feather|fe|system-uicons|gridicons|heroicons-outline|heroicons-solid|ps|el|foundation|typcn|subway|raphael|icons8|wpf|iwwa|topcoat|ei|bytesize|maki|oi|et|fa|zmdi|whh|si-glyph|ls|simple-line-icons|flat-ui|vs|websymbol|il|bpmn|fontelico|noto|noto-v1|twemoji|openmoji|emojione|emojione-monotone|emojione-v1|fxemoji|logos|cib|simple-icons|fa-brands|brandico|entypo-social|cryptocurrency|map|geo|cif|wi|medical-icon):[\w\d-]+/g;

// src/constants.ts
const DEFAULT_API_PATH = "https://raw.githubusercontent.com/iconify/collections-json/master/json";
const DELIMITER = ":";

// src/loader.ts
import axios2 from "axios";
const default_cache = {};
async function fetchCollection(name, source = "auto", remoteDataAPI = DEFAULT_API_PATH, cache = default_cache) {
  if (cache[name])
    return cache[name];
  if (source === "local" || source === "auto") {
    try {
      debug(`fetching collection "${name}" from local packages`);
      const collection = await import(`@iconify/json/json/${name}.json`);
      cache[name] = collection;
      return collection;
    } catch (e) {
      debug(`error on fetching collection "${name}"`, e);
      if (source === "local")
        throw e;
    }
  }
  if (source === "remote" || source === "auto") {
    try {
      const url = `${remoteDataAPI}/${name}.json`;
      debug(`loading collection "${name}" from remote ${url}`);
      const {data} = await axios2.get(url);
      const collection = typeof data === "string" ? JSON.parse(data) : data;
      cache[name] = collection;
      return collection;
    } catch (e) {
      debug(`error on fetching collection "${name}" from remote`, e);
      throw e;
    }
  }
  throw new Error(`Unabled to fetch collection "${name}"`);
}

// src/codegen.ts
import path2 from "path";
import fg from "fast-glob";
import fs from "fs-extra";
async function PurgeIcons(options = {}) {
  const icons = await Extract(options);
  const code = await CodeGen([...icons, ...options.included || []], options);
  return code;
}
const DefaultExtractor = {
  extensions: ["*"],
  extractor(str) {
    return Array.from(str.matchAll(ExtractorRegex)).map((i) => i[0]).filter(Boolean);
  }
};
async function Extract(options = {}) {
  const content = options.content || [];
  const fileGlobs = content.filter((i) => typeof i === "string");
  const rawContents = content.filter((i) => typeof i !== "string");
  const filenames = await fg(fileGlobs, {
    onlyFiles: true,
    ignore: [
      "**/node_modules"
    ]
  });
  const files = [
    ...rawContents,
    ...await Promise.all(filenames.map(async (f) => {
      debug(`extracting from ${f}`);
      return {
        extension: path2.extname(f),
        raw: await fs.readFile(f, "utf-8")
      };
    }))
  ];
  const extractors = [options.defaultExtractor || DefaultExtractor, ...options.extractors || []];
  const keys = new Set();
  for (const file of files) {
    for (const extractor of extractors) {
      const result = await Promise.resolve(extractor.extractor(file.raw));
      for (const key of result)
        keys.add(key);
    }
  }
  return Array.from(keys);
}
function VerifyCollection(name) {
  return CollectionIds.includes(name);
}
function ParseIconNames(icons) {
  var _a;
  const parsed = {};
  for (const icon of icons) {
    const [collection, name] = icon.split(DELIMITER, 2);
    if (!VerifyCollection(collection)) {
      throw new Error(`Invalid collection name: "${collection}"`);
    } else {
      if (!parsed[collection])
        parsed[collection] = [];
      (_a = parsed[collection]) == null ? void 0 : _a.push(name);
    }
  }
  return parsed;
}
async function GetIconsData(icons, options = {}) {
  const parsed = ParseIconNames(icons);
  return await Promise.all(Object.entries(parsed).map(async ([id, icons2]) => {
    const collection = await fetchCollection(id, options.iconSource, options.remoteDataAPI);
    return {
      prefix: id,
      width: collection.width,
      height: collection.height,
      icons: Object.fromEntries(Object.entries(collection.icons).filter(([k]) => icons2 == null ? void 0 : icons2.includes(k)))
    };
  }));
}
async function CodeGen(icons, options = {}) {
  const data = await GetIconsData(icons, options);
  const iconifyImport = options.iconifyImport || "import Iconify from '@iconify/iconify'";
  return `
${iconifyImport}

const collections = JSON.parse('${JSON.stringify(data).replace(/\\/g, "\\\\").replace(/'/g, "\\'")}')

collections.forEach(c => Iconify.addCollection(c))

export default Iconify`;
}

// src/index.ts

export {
  fetchCollection,
  PurgeIcons,
  DefaultExtractor,
  Extract,
  VerifyCollection,
  ParseIconNames,
  GetIconsData,
  CodeGen
};
