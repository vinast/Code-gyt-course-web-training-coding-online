// src/codegen.ts
import path from "path";
import fg from "fast-glob";
import fs from "fs-extra";

// src/utils.ts
import Debug from "debug";
var debug = Debug("purge-icons");

// src/generated/collections.ts
var CollectionIds = [
  "mdi",
  "mdi-light",
  "ic",
  "uil",
  "uim",
  "ph",
  "bx",
  "ri",
  "la",
  "jam",
  "ion",
  "bi",
  "clarity",
  "carbon",
  "cil",
  "gg",
  "tabler",
  "teenyicons",
  "fa-solid",
  "fa-regular",
  "vaadin",
  "icomoon-free",
  "eva",
  "pixelarticons",
  "majesticons",
  "dashicons",
  "entypo",
  "zondicons",
  "flat-color-icons",
  "octicon",
  "codicon",
  "ant-design",
  "feather",
  "fe",
  "radix-icons",
  "line-md",
  "system-uicons",
  "akar-icons",
  "gridicons",
  "heroicons-outline",
  "heroicons-solid",
  "file-icons",
  "mi",
  "ps",
  "el",
  "foundation",
  "typcn",
  "subway",
  "raphael",
  "icons8",
  "wpf",
  "iwwa",
  "topcoat",
  "ei",
  "bytesize",
  "fluent",
  "grommet-icons",
  "maki",
  "oi",
  "et",
  "vscode-icons",
  "fa",
  "zmdi",
  "whh",
  "si-glyph",
  "ls",
  "simple-line-icons",
  "flat-ui",
  "vs",
  "websymbol",
  "il",
  "bpmn",
  "fontelico",
  "noto",
  "noto-v1",
  "twemoji",
  "openmoji",
  "emojione",
  "emojione-monotone",
  "emojione-v1",
  "fxemoji",
  "logos",
  "cib",
  "simple-icons",
  "fa-brands",
  "brandico",
  "entypo-social",
  "cryptocurrency",
  "map",
  "geo",
  "cif",
  "wi",
  "medical-icon"
];
var ExtractorRegex = /(?:mdi|mdi-light|ic|uil|uim|ph|bx|ri|la|jam|ion|bi|clarity|carbon|cil|gg|tabler|teenyicons|fa-solid|fa-regular|vaadin|icomoon-free|eva|pixelarticons|majesticons|dashicons|entypo|zondicons|flat-color-icons|octicon|codicon|ant-design|feather|fe|radix-icons|line-md|system-uicons|akar-icons|gridicons|heroicons-outline|heroicons-solid|file-icons|mi|ps|el|foundation|typcn|subway|raphael|icons8|wpf|iwwa|topcoat|ei|bytesize|fluent|grommet-icons|maki|oi|et|vscode-icons|fa|zmdi|whh|si-glyph|ls|simple-line-icons|flat-ui|vs|websymbol|il|bpmn|fontelico|noto|noto-v1|twemoji|openmoji|emojione|emojione-monotone|emojione-v1|fxemoji|logos|cib|simple-icons|fa-brands|brandico|entypo-social|cryptocurrency|map|geo|cif|wi|medical-icon):[\w\d-]+/g;

// src/loader.ts
import axios from "axios";

// src/constants.ts
var DEFAULT_API_PATH = "https://raw.githubusercontent.com/iconify/collections-json/master/json";
var DELIMITER = ":";

// src/loader.ts
var default_cache = {};
async function fetchCollection(name, source = "auto", remoteDataAPI = DEFAULT_API_PATH, cache = default_cache) {
  if (cache[name])
    return cache[name];
  if (source === "local" || source === "auto") {
    try {
      debug(`fetching collection "${name}" from local packages`);
      const collection = await import(`@iconify/json/json/${name}.json`);
      cache[name] = collection;
      return collection;
    } catch (e) {
      debug(`error on fetching collection "${name}"`, e);
      if (source === "local")
        throw e;
    }
  }
  if (source === "remote" || source === "auto") {
    try {
      const url = `${remoteDataAPI}/${name}.json`;
      debug(`loading collection "${name}" from remote ${url}`);
      const {data} = await axios.get(url);
      const collection = typeof data === "string" ? JSON.parse(data) : data;
      cache[name] = collection;
      return collection;
    } catch (e) {
      debug(`error on fetching collection "${name}" from remote`, e);
      throw e;
    }
  }
  throw new Error(`Unabled to fetch collection "${name}"`);
}

// src/codegen.ts
async function PurgeIcons(options = {}) {
  const icons = await Extract(options);
  const code = await CodeGen([...icons, ...options.included || []], options);
  return code;
}
var DefaultExtractor = {
  extensions: ["*"],
  extractor(str) {
    return Array.from(str.matchAll(ExtractorRegex)).map((i) => i[0]).filter(Boolean);
  }
};
async function Extract(options = {}) {
  const content = options.content || [];
  const fileGlobs = content.filter((i) => typeof i === "string");
  const rawContents = content.filter((i) => typeof i !== "string");
  const filenames = await fg(fileGlobs, {
    onlyFiles: true,
    ignore: [
      "**/node_modules"
    ]
  });
  const files = [
    ...rawContents,
    ...await Promise.all(filenames.map(async (f) => {
      debug(`extracting from ${f}`);
      return {
        extension: path.extname(f),
        raw: await fs.readFile(f, "utf-8")
      };
    }))
  ];
  const extractors = [options.defaultExtractor || DefaultExtractor, ...options.extractors || []];
  const keys = new Set();
  for (const file of files) {
    for (const extractor of extractors) {
      const result = await Promise.resolve(extractor.extractor(file.raw));
      for (const key of result)
        keys.add(key);
    }
  }
  return Array.from(keys);
}
function VerifyCollection(name) {
  return CollectionIds.includes(name);
}
function ParseIconNames(icons) {
  var _a;
  const parsed = {};
  for (const icon of icons) {
    const [collection, name] = icon.split(DELIMITER, 2);
    if (!VerifyCollection(collection)) {
      throw new Error(`Invalid collection name: "${collection}"`);
    } else {
      if (!parsed[collection])
        parsed[collection] = [];
      (_a = parsed[collection]) == null ? void 0 : _a.push(name);
    }
  }
  return parsed;
}
async function GetIconsData(icons, options = {}) {
  const parsed = ParseIconNames(icons);
  return await Promise.all(Object.entries(parsed).map(async ([id, icons2]) => {
    const collection = await fetchCollection(id, options.iconSource, options.remoteDataAPI);
    return {
      prefix: id,
      width: collection.width,
      height: collection.height,
      icons: Object.fromEntries(Object.entries(collection.icons).filter(([k]) => icons2 == null ? void 0 : icons2.includes(k)))
    };
  }));
}
async function CodeGen(icons, options = {}) {
  const data = await GetIconsData(icons, options);
  const json = JSON.stringify(data);
  if (options.format === "json")
    return json;
  const iconifyImport = options.iconifyImportName || "@iconify/iconify";
  let importScript = "";
  let exportScript = "";
  switch (options.format) {
    case "js":
    case "cjs":
      importScript = `const Iconify = require('${iconifyImport}').default`;
      exportScript = "module.exports = Iconify";
      break;
    case "mjs":
    case "ts":
    case void 0:
      importScript = `import Module from '${iconifyImport}'
const Iconify = Module.default || Module`;
      exportScript = "export default Iconify";
      break;
    default:
      throw new Error(`Unknown output format "${options.format}"`);
  }
  return `${importScript}

const collections = JSON.parse('${json.replace(/\\/g, "\\\\").replace(/'/g, "\\'")}')

collections.forEach(c => Iconify.addCollection(c))

${exportScript}
`;
}
export {
  CodeGen,
  DefaultExtractor,
  Extract,
  GetIconsData,
  ParseIconNames,
  PurgeIcons,
  VerifyCollection,
  fetchCollection
};
