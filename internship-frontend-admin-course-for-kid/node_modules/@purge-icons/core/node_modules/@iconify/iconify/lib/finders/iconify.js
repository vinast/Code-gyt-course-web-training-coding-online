import { rotateFromString } from '@iconify/core/lib/customisations/rotate';
import { flipFromString, alignmentFromString, } from '@iconify/core/lib/customisations/shorthand';
/**
 * Check if attribute exists
 */
function hasAttribute(element, key) {
    return element.hasAttribute(key);
}
/**
 * Get attribute value
 */
function getAttribute(element, key) {
    return element.getAttribute(key);
}
/**
 * Get attribute value
 */
function getBooleanAttribute(element, key) {
    const value = element.getAttribute(key);
    if (value === key || value === 'true') {
        return true;
    }
    if (value === '' || value === 'false') {
        return false;
    }
    return null;
}
/**
 * Boolean attributes
 */
const booleanAttributes = [
    'inline',
    'hFlip',
    'vFlip',
];
/**
 * String attributes
 */
const stringAttributes = [
    'width',
    'height',
];
/**
 * Class names
 */
const mainClass = 'iconify';
const inlineClass = 'iconify-inline';
/**
 * Selector combining class names and tags
 */
const selector = 'i.' +
    mainClass +
    ', span.' +
    mainClass +
    ', i.' +
    inlineClass +
    ', span.' +
    inlineClass;
/**
 * Export finder for:
 *  <span class="iconify" />
 *  <i class="iconify" />
 *  <span class="iconify-inline" />
 *  <i class="iconify-inline" />
 */
const finder = {
    /**
     * Find all elements
     */
    find: (root) => root.querySelectorAll(selector),
    /**
     * Get icon name from element
     */
    name: (element) => {
        if (hasAttribute(element, 'data-icon')) {
            return getAttribute(element, 'data-icon');
        }
        return null;
    },
    /**
     * Get customisations list from element
     */
    customisations: (element, defaultValues = {
        inline: false,
    }) => {
        const result = defaultValues;
        // Check class list for inline class
        const className = element.getAttribute('class');
        const classList = className ? className.split(/\s+/) : [];
        if (classList.indexOf(inlineClass) !== -1) {
            result.inline = true;
        }
        // Rotation
        if (hasAttribute(element, 'data-rotate')) {
            const value = rotateFromString(getAttribute(element, 'data-rotate'));
            if (value) {
                result.rotate = value;
            }
        }
        // Shorthand attributes
        if (hasAttribute(element, 'data-flip')) {
            flipFromString(result, getAttribute(element, 'data-flip'));
        }
        if (hasAttribute(element, 'data-align')) {
            alignmentFromString(result, getAttribute(element, 'data-align'));
        }
        // Boolean attributes
        booleanAttributes.forEach((attr) => {
            if (hasAttribute(element, 'data-' + attr)) {
                const value = getBooleanAttribute(element, 'data-' + attr);
                if (typeof value === 'boolean') {
                    result[attr] = value;
                }
            }
        });
        // String attributes
        stringAttributes.forEach((attr) => {
            if (hasAttribute(element, 'data-' + attr)) {
                const value = getAttribute(element, 'data-' + attr);
                if (value !== '') {
                    result[attr] = value;
                }
            }
        });
        return result;
    },
    /**
     * Filter classes
     */
    classFilter: (classList) => {
        let result = [];
        classList.forEach((className) => {
            if (className !== 'iconify' &&
                className !== '' &&
                className.slice(0, 9) !== 'iconify--') {
                result.push(className);
            }
        });
        return result;
    },
};
export { finder };
