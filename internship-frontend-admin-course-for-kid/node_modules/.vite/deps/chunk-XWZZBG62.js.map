{
  "version": 3,
  "sources": ["../../@formkit/utils/dist/index.mjs", "../../@formkit/core/dist/index.mjs", "../../@formkit/inputs/dist/index.mjs"],
  "sourcesContent": ["/**\n * Explicit keys that should always be cloned.\n */\nconst explicitKeys = [\n    '__key',\n    '__init',\n    '__shim',\n    '__original',\n    '__index',\n    '__prevKey',\n];\n/**\n * Generates a random string.\n * @returns string\n * @public\n */\nfunction token() {\n    return Math.random().toString(36).substring(2, 15);\n}\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n * @param items -\n * @returns Set\n * @public\n */\nfunction setify(items) {\n    return items instanceof Set ? items : new Set(items);\n}\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n * @param arr1 -\n * @param arr2 -\n * @returns any[]\n * @public\n */\nfunction dedupe(arr1, arr2) {\n    const original = arr1 instanceof Set ? arr1 : new Set(arr1);\n    if (arr2)\n        arr2.forEach((item) => original.add(item));\n    return [...original];\n}\n/**\n * Checks if the given property exists on the given object.\n * @param obj -\n * @param property -\n * @public\n */\nfunction has(obj, property) {\n    return Object.prototype.hasOwnProperty.call(obj, property);\n}\n/**\n * Compare two values for equality optionally at depth.\n * @param valA - Any type of input\n * @param valB - Any type of output\n * @param deep - Indicate if we should recurse into the object\n * @param explicit - Explicit keys\n * @returns boolean\n * @public\n */\nfunction eq(valA, // eslint-disable-line\nvalB, // eslint-disable-line\ndeep = true, explicit = ['__key']) {\n    if (valA === valB)\n        return true;\n    if (typeof valB === 'object' && typeof valA === 'object') {\n        if (valA instanceof Map)\n            return false;\n        if (valA instanceof Set)\n            return false;\n        if (valA instanceof Date)\n            return false;\n        if (valA === null || valB === null)\n            return false;\n        if (Object.keys(valA).length !== Object.keys(valB).length)\n            return false;\n        for (const k of explicit) {\n            if ((k in valA || k in valB) && valA[k] !== valB[k])\n                return false;\n        }\n        for (const key in valA) {\n            if (!(key in valB))\n                return false;\n            if (valA[key] !== valB[key] && !deep)\n                return false;\n            if (deep && !eq(valA[key], valB[key], deep, explicit))\n                return false;\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if a value is empty or not.\n * @param value - any type of value that could be returned by an input.\n * @public\n */\nfunction empty(value // eslint-disable-line\n) {\n    const type = typeof value;\n    if (type === 'number')\n        return false;\n    if (value === undefined)\n        return true;\n    if (type === 'string') {\n        return value === '';\n    }\n    if (type === 'object') {\n        if (value === null)\n            return true;\n        for (const _i in value)\n            return false;\n        if (value instanceof RegExp)\n            return false;\n        if (value instanceof Date)\n            return false;\n        return true;\n    }\n    return false;\n}\n/**\n * Escape a string for use in regular expressions.\n * @param string - The string to escape.\n * @public\n */\nfunction escapeExp(string) {\n    // $& means the whole matched string\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * Given a string format (date) return a regex to match against.\n * @param format - The format of the string\n * @returns\n * @public\n */\nfunction regexForFormat(format) {\n    const escaped = `^${escapeExp(format)}$`;\n    const formats = {\n        MM: '(0[1-9]|1[012])',\n        M: '([1-9]|1[012])',\n        DD: '([012][0-9]|3[01])',\n        D: '([012]?[0-9]|3[01])',\n        YYYY: '\\\\d{4}',\n        YY: '\\\\d{2}',\n    };\n    const tokens = Object.keys(formats);\n    return new RegExp(tokens.reduce((regex, format) => {\n        return regex.replace(format, formats[format]);\n    }, escaped));\n}\n/**\n * Given a FormKit input type\n * @param type - Any FormKit input type\n * @public\n */\nfunction nodeType(type) {\n    const t = type.toLowerCase();\n    if (t === 'list')\n        return 'list';\n    if (t === 'group')\n        return 'group';\n    return 'input';\n}\n/**\n * Determines if an object is an object or not.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isRecord(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n}\n/**\n * Checks if an object is a simple array or record.\n * @param o - A value to check\n * @returns\n * @public\n */\nfunction isObject(o) {\n    return isRecord(o) || Array.isArray(o);\n}\n/**\n * Attempts to determine if an object is a plain object. Mostly lifted from\n * is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isPojo(o) {\n    if (isRecord(o) === false)\n        return false;\n    if (o.__FKNode__ || o.__POJO__ === false)\n        return false;\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    const prot = ctor.prototype;\n    if (isRecord(prot) === false)\n        return false;\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Recursively merge data from additional into original returning a new object.\n * @param original - An object to extend\n * @param additional - An object to modify the original object with.\n * @param arrays - By default replaces arrays, but can also append to them.\n * @param ignoreUndefined - when true it treats undefined values as if they dont exist\n * @public\n */\nfunction extend(original, additional, extendArrays = false, ignoreUndefined = false) {\n    if (additional === null)\n        return null;\n    const merged = {};\n    if (typeof additional === 'string')\n        return additional;\n    for (const key in original) {\n        if (has(additional, key) &&\n            (additional[key] !== undefined || !ignoreUndefined)) {\n            if (extendArrays &&\n                Array.isArray(original[key]) &&\n                Array.isArray(additional[key])) {\n                merged[key] = original[key].concat(additional[key]);\n                continue;\n            }\n            if (additional[key] === undefined) {\n                continue;\n            }\n            if (isPojo(original[key]) && isPojo(additional[key])) {\n                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);\n            }\n            else {\n                merged[key] = additional[key];\n            }\n        }\n        else {\n            merged[key] = original[key];\n        }\n    }\n    for (const key in additional) {\n        if (!has(merged, key) && additional[key] !== undefined) {\n            merged[key] = additional[key];\n        }\n    }\n    return merged;\n}\n/**\n * Determine if the given string is fully quoted. Examples:\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * @param str - A string to check.\n * @public\n */\nfunction isQuotedString(str) {\n    // quickly return false if the value is note quoted\n    if (str[0] !== '\"' && str[0] !== \"'\")\n        return false;\n    if (str[0] !== str[str.length - 1])\n        return false;\n    const quoteType = str[0];\n    for (let p = 1; p < str.length; p++) {\n        if (str[p] === quoteType &&\n            (p === 1 || str[p - 1] !== '\\\\') &&\n            p !== str.length - 1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove extra escape characters.\n * @param str - A string to remove escape characters from.\n * @public\n */\nfunction rmEscapes(str) {\n    if (!str.length)\n        return '';\n    let clean = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char !== '\\\\' || lastChar === '\\\\') {\n            clean += char;\n        }\n        lastChar = char;\n    }\n    return clean;\n}\n/**\n * Performs a recursive Object.assign like operation.\n * @param a - An object to be extended by object b\n * @param b - An object to copy values from\n * @public\n */\nfunction assignDeep(a, b) {\n    for (const key in a) {\n        if (has(b, key) &&\n            a[key] !== b[key] &&\n            !(isPojo(a[key]) && isPojo(b[key]))) {\n            a[key] = b[key];\n        }\n        else if (isPojo(a[key]) && isPojo(b[key])) {\n            assignDeep(a[key], b[key]);\n        }\n    }\n    for (const key in b) {\n        if (!has(a, key)) {\n            a[key] = b[key];\n        }\n    }\n    return a;\n}\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n * @param attrs - An object to extract core node config from.\n * @public\n */\nfunction nodeProps(...sets) {\n    return sets.reduce((valid, props) => {\n        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line\n        return Object.assign(valid, validProps);\n    }, {});\n}\n/**\n * Parse a string for comma-separated arguments\n * @param str - A string to parse\n * @public\n */\nfunction parseArgs(str) {\n    const args = [];\n    let arg = '';\n    let depth = 0;\n    let quote = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char === quote && lastChar !== '\\\\') {\n            quote = '';\n        }\n        else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n            quote = char;\n        }\n        else if (char === '(' && !quote) {\n            depth++;\n        }\n        else if (char === ')' && !quote) {\n            depth--;\n        }\n        if (char === ',' && !quote && depth === 0) {\n            args.push(arg);\n            arg = '';\n        }\n        else if (char !== ' ' || quote) {\n            arg += char;\n        }\n        lastChar = char;\n    }\n    if (arg) {\n        args.push(arg);\n    }\n    return args;\n}\n/**\n * Return a new (shallow) object with all properties from a given object\n * that are present in the array.\n * @param obj - An object to clone\n * @param toRemove - An array of keys to remove\n * @public\n */\nfunction except(obj, toRemove) {\n    const clean = {};\n    const exps = toRemove.filter((n) => n instanceof RegExp);\n    const keysToRemove = new Set(toRemove);\n    for (const key in obj) {\n        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    }\n    return clean;\n}\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object they will just have an\n * undefined value.\n * @param obj - An object to extract values from\n * @param include - A set of keys to extract\n * @returns\n * @public\n */\nfunction only(obj, include) {\n    const clean = {};\n    const exps = include.filter((n) => n instanceof RegExp);\n    include.forEach((key) => {\n        if (!(key instanceof RegExp)) {\n            clean[key] = obj[key];\n        }\n    });\n    Object.keys(obj).forEach((key) => {\n        if (exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    });\n    return clean;\n}\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab for\n * efficiency stake.\n * @param str - String to convert.\n * @public\n */\nfunction camel(str) {\n    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());\n}\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n * @param str - Converts camel to kebab\n * @returns\n * @public\n */\nfunction kebab(str) {\n    return str\n        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())\n        .replace(' ', '-')\n        .toLowerCase();\n}\n/**\n * Very shallowly clones the given object.\n * @param obj - The object to shallow clone\n * @returns\n * @public\n */\nfunction shallowClone(obj, explicit = explicitKeys) {\n    if (obj !== null && typeof obj === 'object') {\n        let returnObject;\n        if (Array.isArray(obj))\n            returnObject = [...obj];\n        else if (isPojo(obj))\n            returnObject = { ...obj };\n        if (returnObject) {\n            applyExplicit(obj, returnObject, explicit);\n            return returnObject;\n        }\n    }\n    return obj;\n}\n/**\n * Perform a recursive clone on a given object. This only intended to be used\n * for simple objects like arrays and pojos.\n * @param obj - Object to clone\n * @public\n */\nfunction clone(obj, explicit = explicitKeys) {\n    if (obj === null ||\n        obj instanceof RegExp ||\n        obj instanceof Date ||\n        obj instanceof Map ||\n        obj instanceof Set ||\n        (typeof File === 'function' && obj instanceof File))\n        return obj;\n    let returnObject;\n    if (Array.isArray(obj)) {\n        returnObject = obj.map((value) => {\n            if (typeof value === 'object')\n                return clone(value, explicit);\n            return value;\n        });\n    }\n    else {\n        returnObject = Object.keys(obj).reduce((newObj, key) => {\n            newObj[key] =\n                typeof obj[key] === 'object'\n                    ? clone(obj[key], explicit)\n                    : obj[key];\n            return newObj;\n        }, {});\n    }\n    for (const key of explicit) {\n        if (key in obj) {\n            Object.defineProperty(returnObject, key, {\n                enumerable: false,\n                value: obj[key],\n            });\n        }\n    }\n    return returnObject;\n}\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. if it\n * is an object, it performs a (fast/loose) clone operation.\n * @param obj - The object to clone\n * @public\n */\nfunction cloneAny(obj) {\n    return typeof obj === 'object'\n        ? clone(obj)\n        : obj;\n}\n/**\n * Get a specific value via dot notation.\n * @param obj - An object to fetch data from\n * @param addr - An \"address\" in dot notation\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getAt(obj, addr) {\n    if (!obj || typeof obj !== 'object')\n        return null;\n    const segments = addr.split('.');\n    let o = obj;\n    for (const i in segments) {\n        const segment = segments[i];\n        if (has(o, segment)) {\n            o = o[segment];\n        }\n        if (+i === segments.length - 1)\n            return o;\n        if (!o || typeof o !== 'object')\n            return null;\n    }\n    return null;\n}\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (undefined). For example the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" \u2014 then it\n * should not be disabled.\n * @param value - value to be checked\n * @returns\n * @public\n */\nfunction undefine(value) {\n    return value !== undefined && value !== 'false' && value !== false\n        ? true\n        : undefined;\n}\n/**\n * Defines an object as an initial value.\n * @param obj - Object\n * @returns\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nfunction init(obj) {\n    return !Object.isFrozen(obj)\n        ? Object.defineProperty(obj, '__init', {\n            enumerable: false,\n            value: true,\n        })\n        : obj;\n}\n/**\n * Turn any string into a URL/DOM safe string.\n * @public\n */\nfunction slugify(str) {\n    return str\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .toLowerCase()\n        .replace(/[^a-z0-9]/g, ' ')\n        .trim()\n        .replace(/\\s+/g, '-');\n}\n/**\n * Spreads an object or an array, otherwise returns the same value.\n * @param obj - Any value, but will spread objects and arrays\n * @public\n */\nfunction spread(obj, explicit = explicitKeys) {\n    if (obj && typeof obj === 'object') {\n        if (obj instanceof RegExp)\n            return obj;\n        if (obj instanceof Date)\n            return obj;\n        let spread;\n        if (Array.isArray(obj)) {\n            spread = [...obj];\n        }\n        else {\n            spread = { ...obj };\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        return applyExplicit(obj, spread, explicit);\n    }\n    return obj;\n}\n/**\n * Apply non enumerable properties to an object.\n * @param obj - The object to apply non-enumerable properties to\n * @param explicit - An array of non-enumerable properties to apply\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction applyExplicit(original, obj, explicit) {\n    for (const key of explicit) {\n        if (key in original) {\n            Object.defineProperty(obj, key, {\n                enumerable: false,\n                value: original[key],\n            });\n        }\n    }\n    return obj;\n}\n\nexport { assignDeep, camel, clone, cloneAny, dedupe, empty, eq, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, isRecord, kebab, nodeProps, nodeType, only, parseArgs, regexForFormat, rmEscapes, setify, shallowClone, slugify, spread, token, undefine };\n", "import { token, slugify, has, cloneAny, init, clone, camel, undefine, eq, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n * @returns FormKitDispatcher\n */\nfunction createDispatcher() {\n    const middleware = [];\n    let currentIndex = 0;\n    const use = (dispatchable) => middleware.push(dispatchable);\n    const dispatch = (payload) => {\n        const current = middleware[currentIndex];\n        if (typeof current === 'function') {\n            return current(payload, (explicitPayload) => {\n                currentIndex++;\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n            });\n        }\n        currentIndex = 0;\n        return payload;\n    };\n    use.dispatch = dispatch;\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\n    use.remove = (dispatchable) => {\n        const index = middleware.indexOf(dispatchable);\n        if (index > -1)\n            middleware.splice(index, 1);\n    };\n    return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n * @returns FormKitEventEmitter\n */\nfunction createEmitter() {\n    const listeners = new Map();\n    const receipts = new Map();\n    let buffer = undefined;\n    const emitter = (node, event) => {\n        if (buffer) {\n            buffer.set(event.name, [node, event]);\n            return;\n        }\n        if (listeners.has(event.name)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            listeners.get(event.name).forEach((wrapper) => {\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\n                    wrapper.listener(event);\n                }\n            });\n        }\n        if (event.bubble) {\n            node.bubble(event);\n        }\n    };\n    /**\n     * Add an event listener\n     * @param eventName - The name of the event to listen to\n     * @param listener - The callback\n     * @returns string\n     */\n    emitter.on = (eventName, listener) => {\n        const [event, ...modifiers] = eventName.split('.');\n        const receipt = listener.receipt || token();\n        const wrapper = {\n            modifiers,\n            event,\n            listener,\n            receipt,\n        };\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        listeners.has(event)\n            ? listeners.get(event).push(wrapper)\n            : listeners.set(event, [wrapper]);\n        receipts.has(receipt)\n            ? receipts.get(receipt).push(event)\n            : receipts.set(receipt, [event]);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return receipt;\n    };\n    /**\n     * Remove an event listener\n     * @param listenerOrReceipt - Either a receipt or the callback function.\n     */\n    emitter.off = (receipt) => {\n        var _a;\n        if (receipts.has(receipt)) {\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\n                const eventListeners = listeners.get(event);\n                if (Array.isArray(eventListeners)) {\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\n                }\n            });\n            receipts.delete(receipt);\n        }\n    };\n    /**\n     * Pause emitting values. Any events emitted while paused will not be emitted\n     * but rather \"stored\" \u2014\u00A0and whichever events are emitted last will be output.\n     * For example:\n     * pause()\n     * emit('foo', 1)\n     * emit('foo', 2)\n     * emit('bar', 3)\n     * emit('bar', 4)\n     * play()\n     * // would result in\n     * emit('foo', 2)\n     * emit('bar', 4)\n     * Optionally pauses all children as well.\n     * @param node - A node to pause all children on.\n     */\n    emitter.pause = (node) => {\n        if (!buffer)\n            buffer = new Map();\n        if (node) {\n            node.walk((child) => child._e.pause());\n        }\n    };\n    /**\n     * Release the current event buffer.\n     * @param node - A node to unpause all children on.\n     */\n    emitter.play = (node) => {\n        if (!buffer)\n            return;\n        const events = buffer;\n        buffer = undefined;\n        events.forEach(([node, event]) => emitter(node, event));\n        if (node) {\n            node.walk((child) => child._e.play());\n        }\n    };\n    return emitter;\n}\n/**\n * Emit an event from this node.\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n * @returns FormKitNode\n */\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n    context._e(node, {\n        payload,\n        name,\n        bubble,\n        origin: node,\n    });\n    return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n * @param node -\n * @param _context -\n * @param event -\n */\nfunction bubble(node, _context, event) {\n    if (isNode(node.parent)) {\n        node.parent._e(node.parent, event);\n    }\n    return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n * @returns FormKitNode\n */\nfunction on(_node, context, name, listener) {\n    return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n * @returns FormKitNode\n */\nfunction off(node, context, receipt) {\n    context._e.off(receipt);\n    return node;\n}\n\n/**\n * FormKit's global error handler.\n * @public\n */\nconst errorHandler = createDispatcher();\n/**\n * The default error handler just sets the error as the message.\n */\nerrorHandler((error, next) => {\n    if (!error.message)\n        error.message = String(`E${error.code}`);\n    return next(error);\n});\n/**\n * FormKit's global warning handler.\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n    if (!warning.message)\n        warning.message = String(`W${warning.code}`);\n    const result = next(warning);\n    if (console && typeof console.warn === 'function')\n        console.warn(result.message);\n    return result;\n});\n/**\n * Globally emits a warning.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction warn(code, data = {}) {\n    warningHandler.dispatch({ code, data });\n}\n/**\n * Emits an error, generally should result in an exception.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction error(code, data = {}) {\n    throw Error(errorHandler.dispatch({ code, data }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n * @param conf - The message configuration\n * @returns FormKitMessage\n * @public\n */\nfunction createMessage(conf, node) {\n    const m = {\n        blocking: false,\n        key: token(),\n        meta: {},\n        type: 'state',\n        visible: true,\n        ...conf,\n    };\n    if (node && m.value && m.meta.localize !== false) {\n        m.value = node.t(m);\n        m.meta.locale = node.config.locale;\n    }\n    return m;\n}\n/**\n * The available traps on the node's store.\n */\nconst storeTraps = {\n    apply: applyMessages,\n    set: setMessage,\n    remove: removeMessage,\n    filter: filterMessages,\n    reduce: reduceMessages,\n    release: releaseBuffer,\n    touch: touchMessages,\n};\n/**\n * Creates a new FormKit message store.\n * @returns FormKitStore\n */\nfunction createStore(_buffer = false) {\n    const messages = {};\n    let node;\n    let buffer = _buffer;\n    let _b = [];\n    const _m = new Map();\n    let _r = undefined;\n    const store = new Proxy(messages, {\n        get(...args) {\n            const [_target, property] = args;\n            if (property === 'buffer')\n                return buffer;\n            if (property === '_b')\n                return _b;\n            if (property === '_m')\n                return _m;\n            if (property === '_r')\n                return _r;\n            if (has(storeTraps, property)) {\n                return storeTraps[property].bind(null, messages, store, node);\n            }\n            return Reflect.get(...args);\n        },\n        set(_t, prop, value) {\n            if (prop === '_n') {\n                node = value;\n                if (_r === '__n')\n                    releaseMissed(node, store);\n                return true;\n            }\n            else if (prop === '_b') {\n                _b = value;\n                return true;\n            }\n            else if (prop === 'buffer') {\n                buffer = value;\n                return true;\n            }\n            else if (prop === '_r') {\n                _r = value;\n                return true;\n            }\n            error(101, node);\n            return false;\n        },\n    });\n    return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n * @returns FormKitStore\n */\nfunction setMessage(messageStore, store, node, message) {\n    if (store.buffer) {\n        store._b.push([[message]]);\n        return store;\n    }\n    if (messageStore[message.key] !== message) {\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\n            // Expose the value to translation\n            const previous = message.value;\n            message.value = node.t(message);\n            if (message.value !== previous) {\n                message.meta.locale = node.props.locale;\n            }\n        }\n        const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\n        messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\n        node.emit(e, message);\n    }\n    return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n */\nfunction touchMessages(messageStore, store) {\n    for (const key in messageStore) {\n        const message = { ...messageStore[key] };\n        store.set(message);\n    }\n}\n/**\n * Remove a message from the store.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n * @returns FormKitStore\n */\nfunction removeMessage(messageStore, store, node, key) {\n    if (has(messageStore, key)) {\n        const message = messageStore[key];\n        delete messageStore[key];\n        node.emit('message-removed', message);\n    }\n    if (store.buffer === true) {\n        store._b = store._b.filter((buffered) => {\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\n            return buffered[1] || buffered[0].length;\n        });\n    }\n    return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        if ((!type || message.type === type) && !callback(message)) {\n            removeMessage(messageStore, store, node, key);\n        }\n    }\n}\n/**\n * Reduce the message store to some other generic value.\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n * @returns\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        accumulator = reducer(accumulator, message);\n    }\n    return accumulator;\n}\n/**\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n    if (Array.isArray(messages)) {\n        if (store.buffer) {\n            store._b.push([messages, clear]);\n            return;\n        }\n        // In this case we are applying messages to this node\u2019s store.\n        const applied = new Set(messages.map((message) => {\n            store.set(message);\n            return message.key;\n        }));\n        // Remove any messages that were not part of the initial apply:\n        if (typeof clear === 'string') {\n            store.filter((message) => message.type !== clear || applied.has(message.key));\n        }\n        else if (typeof clear === 'function') {\n            store.filter((message) => !clear(message) || applied.has(message.key));\n        }\n    }\n    else {\n        for (const address in messages) {\n            const child = node.at(address);\n            if (child) {\n                child.store.apply(messages[address], clear);\n            }\n            else {\n                missed(node, store, address, messages[address], clear);\n            }\n        }\n    }\n}\n/**\n * Creates an array of message arrays from strings.\n * @param errors - Arrays or objects of form errors or input errors\n * @returns\n * @internal\n */\nfunction createMessages(node, ...errors) {\n    const sourceKey = `${node.name}-set`;\n    const make = (error) => createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: sourceKey, autoClear: true },\n    });\n    return errors\n        .filter((m) => !!m)\n        .map((errorSet) => {\n        if (typeof errorSet === 'string')\n            errorSet = [errorSet];\n        if (Array.isArray(errorSet)) {\n            return errorSet.map((error) => make(error));\n        }\n        else {\n            const errors = {};\n            for (const key in errorSet) {\n                if (Array.isArray(errorSet[key])) {\n                    errors[key] = errorSet[key].map((error) => make(error));\n                }\n                else {\n                    errors[key] = [make(errorSet[key])];\n                }\n            }\n            return errors;\n        }\n    });\n}\n/**\n *\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n */\nfunction missed(node, store, address, messages, clear) {\n    var _a;\n    const misses = store._m;\n    if (!misses.has(address))\n        misses.set(address, []);\n    // The created receipt\n    if (!store._r)\n        store._r = releaseMissed(node, store);\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n * @param store - The store object.\n * @returns\n */\nfunction releaseMissed(node, store) {\n    return node.on('child.deep', ({ payload: child }) => {\n        store._m.forEach((misses, address) => {\n            if (node.at(address) === child) {\n                misses.forEach(([messages, clear]) => {\n                    child.store.apply(messages, clear);\n                });\n                store._m.delete(address);\n            }\n        });\n        // If all the stored misses were applied, remove the listener.\n        if (store._m.size === 0 && store._r) {\n            node.off(store._r);\n            store._r = undefined;\n        }\n    });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n */\nfunction releaseBuffer(_messageStore, store) {\n    store.buffer = false;\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n    store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n * @returns\n */\nfunction createLedger() {\n    const ledger = {};\n    let n;\n    return {\n        count: (...args) => createCounter(n, ledger, ...args),\n        init(node) {\n            n = node;\n            node.on('message-added.deep', add(ledger, 1));\n            node.on('message-removed.deep', add(ledger, -1));\n        },\n        merge: (child) => merge(n, ledger, child),\n        settled(counterName) {\n            return has(ledger, counterName)\n                ? ledger[counterName].promise\n                : Promise.resolve();\n        },\n        unmerge: (child) => merge(n, ledger, child, true),\n        value(counterName) {\n            return has(ledger, counterName) ? ledger[counterName].count : 0;\n        },\n    };\n}\n/**\n * Creates a new counter object in the counting ledger.\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param initialValue - The initial counter value\n * @returns\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n    condition = parseCondition(condition || counterName);\n    if (!has(ledger, counterName)) {\n        const counter = {\n            condition,\n            count: 0,\n            name: counterName,\n            node,\n            promise: Promise.resolve(),\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\n        };\n        ledger[counterName] = counter;\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n        node.each((child) => {\n            child.ledger.count(counter.name, counter.condition);\n            increment += child.ledger.value(counter.name);\n        });\n    }\n    return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n * @param condition - The condition that, if true, allows a message to change a counter's value\n * @returns\n */\nfunction parseCondition(condition) {\n    if (typeof condition === 'function') {\n        return condition;\n    }\n    return (m) => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n * @returns\n */\nfunction count(counter, increment) {\n    const initial = counter.count;\n    const post = counter.count + increment;\n    counter.count = post;\n    if (initial === 0 && post !== 0) {\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n        counter.promise = new Promise((r) => (counter.resolve = r));\n    }\n    else if (initial !== 0 && post === 0) {\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\n        counter.resolve();\n    }\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\n    return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n * @returns\n */\nfunction add(ledger, delta) {\n    return (e) => {\n        for (const name in ledger) {\n            const counter = ledger[name];\n            if (counter.condition(e.payload)) {\n                count(counter, delta);\n            }\n        }\n    };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n */\nfunction merge(parent, ledger, child, remove = false) {\n    for (const key in ledger) {\n        const condition = ledger[key].condition;\n        if (!remove)\n            child.ledger.count(key, condition);\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\n        if (!parent)\n            continue;\n        do {\n            parent.ledger.count(key, condition, increment);\n            parent = parent.parent;\n        } while (parent);\n    }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true\n * then no node is registered (idempotent).\n *\n * @param node - A node to register\n * @public\n */\nfunction register(node) {\n    if (node.props.id) {\n        registry.set(node.props.id, node);\n        reflected.set(node, node.props.id);\n        emit(node, {\n            payload: node,\n            name: node.props.id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Deregister a node from the registry.\n * @param node - A node to remove\n * @public\n */\nfunction deregister(node) {\n    if (reflected.has(node)) {\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reflected.delete(node);\n        registry.delete(id);\n        emit(node, {\n            payload: null,\n            name: id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Get a node by a particular id.\n * @param node - Get a node by a given id\n * @public\n */\nfunction getNode$1(id) {\n    return registry.get(id);\n}\n/**\n * Reset the entire registry.\n * @public\n */\nfunction resetRegistry() {\n    registry.forEach((node) => {\n        deregister(node);\n    });\n    receipts.forEach((receipt) => emit.off(receipt));\n}\n/**\n *\n * @param id - An id to watch\n * @param callback - A callback to notify when the node is set or removed.\n * @public\n */\nfunction watchRegistry(id, callback) {\n    // register a listener\n    receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n * @internal\n */\nfunction configChange(node, prop, value) {\n    // When we return false, node.walk will not continue into that child.\n    let usingFallback = true;\n    !(prop in node.config._t)\n        ? node.emit(`config:${prop}`, value, false)\n        : (usingFallback = false);\n    if (!(prop in node.props)) {\n        node.emit('prop', { prop, value });\n        node.emit(`prop:${prop}`, value);\n    }\n    return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - FormKit node options to be used globally.\n * @public\n */\nfunction createConfig$1(options = {}) {\n    const nodes = new Set();\n    const target = {\n        ...options,\n        ...{\n            _add: (node) => nodes.add(node),\n            _rm: (node) => node.remove(node),\n        },\n    };\n    const rootConfig = new Proxy(target, {\n        set(t, prop, value, r) {\n            if (typeof prop === 'string') {\n                nodes.forEach((node) => configChange(node, prop, value));\n            }\n            return Reflect.set(t, prop, value, r);\n        },\n    });\n    return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n * @param id - The id of the form\n * @public\n */\nfunction submitForm(id) {\n    const formElement = document.getElementById(id);\n    if (formElement instanceof HTMLFormElement) {\n        const event = new Event('submit', { cancelable: true, bubbles: true });\n        formElement.dispatchEvent(event);\n        return;\n    }\n    warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n */\nfunction clearState(node) {\n    const clear = (n) => {\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'error' ||\n                (message.type === 'ui' && key === 'incomplete')) {\n                n.store.remove(key);\n            }\n            else if (message.type === 'state') {\n                n.store.set({ ...message, value: false });\n            }\n        }\n    };\n    clear(node);\n    node.walk(clear);\n}\n/**\n * Resets an input to it\u2019s \"initial\" value \u2014 if the input is a group or list it\n * resets all the children as well.\n * @param id - The id of an input to reset\n * @returns\n * @public\n */\nfunction reset(id, resetTo) {\n    const node = typeof id === 'string' ? getNode$1(id) : id;\n    if (node) {\n        const initial = (n) => cloneAny(n.props.initial) ||\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n        // pause all events in this tree.\n        node._e.pause(node);\n        // Set it back to basics\n        node.input(cloneAny(resetTo) || initial(node), false);\n        // Set children back to basics in case they were additive (had their own value for example)\n        node.walk((child) => child.input(initial(child), false));\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\n        // take precedence over child values.\n        const finalInit = initial(node);\n        node.input(typeof finalInit === 'object'\n            ? cloneAny(resetTo) || init(finalInit)\n            : finalInit, false);\n        // release the events.\n        node._e.play(node);\n        clearState(node);\n        node.emit('reset', node);\n        return node;\n    }\n    warn(152, id);\n    return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n    delimiter: '.',\n    delay: 0,\n    locale: 'en',\n    rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true }),\n};\n/**\n * If a node\u2019s name is set to useIndex, it replaces the node\u2019s name with the\n * index of the node relative to its parent\u2019s children.\n * @public\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n * @public\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n * @public\n */\nconst valueMoved = Symbol('moved');\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n * @public\n */\nconst valueInserted = Symbol('inserted');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n * @param arg -\n * @returns arg is FormKitListContext\n * @public\n */\nfunction isList(arg) {\n    return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n    return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n    error(102, [node, property]);\n};\nconst traps = {\n    _c: trap(getContext, invalidSetter, false),\n    add: trap(addChild),\n    addProps: trap(addProps),\n    address: trap(getAddress, invalidSetter, false),\n    at: trap(getNode),\n    bubble: trap(bubble),\n    clearErrors: trap(clearErrors$1),\n    calm: trap(calm),\n    config: trap(false),\n    define: trap(define),\n    disturb: trap(disturb),\n    destroy: trap(destroy),\n    hydrate: trap(hydrate),\n    index: trap(getIndex, setIndex, false),\n    input: trap(input),\n    each: trap(eachChild),\n    emit: trap(emit$1),\n    find: trap(find),\n    on: trap(on),\n    off: trap(off),\n    parent: trap(false, setParent),\n    plugins: trap(false),\n    remove: trap(removeChild),\n    root: trap(getRoot, invalidSetter, false),\n    reset: trap(resetValue),\n    resetConfig: trap(resetConfig),\n    setErrors: trap(setErrors$1),\n    submit: trap(submit),\n    t: trap(text),\n    use: trap(use),\n    name: trap(getName, false, false),\n    walk: trap(walkTree),\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n    return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n * @returns\n */\nfunction trap(getter, setter, curryGetter = true) {\n    return {\n        get: getter\n            ? (node, context) => curryGetter\n                ? (...args) => getter(node, context, ...args)\n                : getter(node, context)\n            : false,\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\n    };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n    const hooks = new Map();\n    return new Proxy(hooks, {\n        get(_, property) {\n            if (!hooks.has(property)) {\n                hooks.set(property, createDispatcher());\n            }\n            return hooks.get(property);\n        },\n    });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Reports the global number of node registrations, useful for deterministic\n * node naming.\n * @public\n */\nfunction resetCount() {\n    nameCount = 0;\n    idCount = 0;\n}\n/**\n * Create a name based dictionary of all children in an array.\n * @param children -\n * @public\n */\nfunction names(children) {\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options -\n * @returns string\n */\nfunction createName(options) {\n    var _a, _b;\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return useIndex;\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n * @param options -\n * @param type -\n * @returns\n * @internal\n */\nfunction createValue(options) {\n    if (options.type === 'group') {\n        return init(options.value &&\n            typeof options.value === 'object' &&\n            !Array.isArray(options.value)\n            ? options.value\n            : {});\n    }\n    else if (options.type === 'list') {\n        return init(Array.isArray(options.value) ? options.value : []);\n    }\n    return options.value;\n}\n/**\n * Sets the internal value of the node.\n * @param node -\n * @param context -\n * @param value -\n * @returns T\n */\nfunction input(node, context, value, async = true) {\n    context._value = validateInput(node, node.hook.input.dispatch(value));\n    node.emit('input', context._value);\n    if (context.isSettled)\n        node.disturb();\n    if (async) {\n        if (context._tmo)\n            clearTimeout(context._tmo);\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\n    }\n    else {\n        commit(node, context);\n    }\n    return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n * @param type - The type of node (input, list, group)\n * @param value - The value that is being set\n */\nfunction validateInput(node, value) {\n    switch (node.type) {\n        // Inputs are allowed to have any type\n        case 'input':\n            break;\n        case 'group':\n            if (!value || typeof value !== 'object')\n                error(107, [node, value]);\n            break;\n        case 'list':\n            if (!Array.isArray(value))\n                error(108, [node, value]);\n            break;\n    }\n    return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n * @param node -\n * @param context -\n * @param calm -\n * @param hydrate -\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n    context._value = context.value = node.hook.commit.dispatch(context._value);\n    if (node.type !== 'input' && hydrate)\n        node.hydrate();\n    node.emit('commit', context.value);\n    if (calm)\n        node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n * @param context -\n * @param name -\n * @param value -\n */\nfunction partial(context, { name, value, from }) {\n    if (Object.isFrozen(context._value))\n        return;\n    if (isList(context)) {\n        const insert = value === valueRemoved\n            ? []\n            : value === valueMoved && typeof from === 'number'\n                ? context._value.splice(from, 1)\n                : [value];\n        context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\n        return;\n    }\n    // In this case we know for sure we're dealing with a group, TS doesn't\n    // know that however, so we use some unpleasant casting here\n    if (value !== valueRemoved) {\n        context._value[name] = value;\n    }\n    else {\n        delete context._value[name];\n    }\n}\n/**\n * Pass values down to children by calling hydrate on them.\n * @param parent -\n * @param child -\n */\nfunction hydrate(node, context) {\n    const _value = context._value;\n    context.children.forEach((child) => {\n        if (typeof _value !== 'object')\n            return;\n        // if (has(context._value as FormKitGroupValue, child.name)) {\n        if (child.name in _value) {\n            // In this case, the parent has a value to give to the child, so we\n            // perform a down-tree synchronous input which will cascade values down\n            // and then ultimately back up.\n            const childValue = child.type !== 'input' ||\n                (_value[child.name] && typeof _value[child.name] === 'object')\n                ? init(_value[child.name])\n                : _value[child.name];\n            child.input(childValue, false);\n        }\n        else {\n            if (node.type !== 'list' || typeof child.name === 'number') {\n                // In this case, the parent\u2019s values have no knowledge of the child\n                // value \u2014 this typically occurs on the commit at the end of addChild()\n                // we need to create a value reservation for this node\u2019s name. This is\n                // especially important when dealing with lists where index matters.\n                partial(context, { name: child.name, value: child.value });\n            }\n            if (!_value.__init) {\n                // In this case, someone has explicitly set the value to an empty object\n                // with node.input({}) so we do not define the __init property:\n                if (child.type === 'group')\n                    child.input({}, false);\n                else if (child.type === 'list')\n                    child.input([], false);\n                else\n                    child.input(undefined, false);\n            }\n        }\n    });\n    return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled\u00A0\u2014 creating appropriate\n * promises and resolutions.\n * @param node -\n * @param context -\n */\nfunction disturb(node, context) {\n    var _a;\n    if (context._d <= 0) {\n        context.isSettled = false;\n        node.emit('settled', false, false);\n        context.settled = new Promise((resolve) => {\n            context._resolve = resolve;\n        });\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n    }\n    context._d++;\n    return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n * @param node -\n * @param context -\n */\nfunction calm(node, context, value) {\n    var _a;\n    if (value !== undefined && node.type !== 'input') {\n        partial(context, value);\n        // Commit the value up, but do not hydrate back down\n        return commit(node, context, true, false);\n    }\n    if (context._d > 0)\n        context._d--;\n    if (context._d === 0) {\n        context.isSettled = true;\n        node.emit('settled', true, false);\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\n        if (context._resolve)\n            context._resolve(context.value);\n    }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n * @param node - The node to shut down\n * @param context - The context to clean up\n */\nfunction destroy(node, context) {\n    node.emit('destroying', node);\n    // flush all messages out\n    node.store.filter(() => false);\n    if (node.parent) {\n        node.parent.remove(node);\n    }\n    deregister(node);\n    context._value = context.value = undefined;\n    node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n * @param definition - The definition of the current input type.\n */\nfunction define(node, context, definition) {\n    // Assign the type\n    context.type = definition.type;\n    // Assign the definition\n    context.props.definition = clone(definition);\n    // Ensure the type is seeded with the `__init` value.\n    context.value = context._value = createValue({\n        type: node.type,\n        value: context.value,\n    });\n    /**\n     * If the user has a typename defined, use it here.\n     */\n    if (definition.forceTypeProp) {\n        if (node.props.type)\n            node.props.originalType = node.props.type;\n        context.props.type = definition.forceTypeProp;\n    }\n    /**\n     * If the input is part of a family of inputs, add that prop.\n     */\n    if (definition.family) {\n        context.props.family = definition.family;\n    }\n    // Apply any input features before resetting the props.\n    if (definition.features) {\n        definition.features.forEach((feature) => feature(node));\n    }\n    // Its possible that input-defined \"props\" have ended up in the context attrs\n    // these should be moved back out of the attrs object.\n    if (definition.props) {\n        node.addProps(definition.props);\n    }\n    node.emit('defined', definition);\n}\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - The node to add props to\n * @param context - The internal context object\n * @param props - An array of prop strings (in camelCase!)\n */\nfunction addProps(node, context, props) {\n    var _a;\n    if (node.props.attrs) {\n        const attrs = { ...node.props.attrs };\n        // Temporarily disable prop emits\n        node.props._emit = false;\n        for (const attr in attrs) {\n            const camelName = camel(attr);\n            if (props.includes(camelName)) {\n                node.props[camelName] = attrs[attr];\n                delete attrs[attr];\n            }\n        }\n        const initial = cloneAny(context._value);\n        node.props.initial =\n            node.type !== 'input' ? init(initial) : initial;\n        // Re-enable prop emits\n        node.props._emit = true;\n        node.props.attrs = attrs;\n        if (node.props.definition) {\n            node.props.definition.props = [\n                ...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []),\n                ...props,\n            ];\n        }\n    }\n    node.emit('added-props', props);\n    return node;\n}\n/**\n * (node.add) Adds a child to the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction addChild(parent, parentContext, child, listIndex) {\n    if (parent.type === 'input')\n        error(100, parent);\n    if (child.parent && child.parent !== parent) {\n        child.parent.remove(child);\n    }\n    // Synchronously set the initial value on the parent\n    if (!parentContext.children.includes(child)) {\n        if (listIndex !== undefined && parent.type === 'list') {\n            // Inject the child:\n            parentContext.children.splice(listIndex, 0, child);\n            if (Array.isArray(parent.value) &&\n                parent.value.length < parentContext.children.length) {\n                // When adding an node or value to a list it is absolutely critical to\n                // know if, at the moment of injection, the parent\u2019s value or the node\n                // children are the source of truth. For example, if a user pushes or\n                // splices a new value onto the lists\u2019s array then we want to use that\n                // value as the value of the new node, but if a user adds a node to the\n                // list then we want the node\u2019s value. In this specific case, we\n                // assume (due to length) that a new node was injected into the list, so\n                // we want that new node\u2019s value injected into the parent list value.\n                parent.disturb().calm({\n                    name: listIndex,\n                    value: child.value,\n                    from: valueInserted,\n                });\n            }\n        }\n        else {\n            parentContext.children.push(child);\n        }\n        if (!child.isSettled)\n            parent.disturb();\n    }\n    if (child.parent !== parent) {\n        child.parent = parent;\n        // In this edge case middleware changed the parent assignment so we need to\n        // re-add the child\n        if (child.parent !== parent) {\n            parent.remove(child);\n            child.parent.add(child);\n            return parent;\n        }\n    }\n    else {\n        // When a parent is properly assigned, we inject the parent's plugins on the\n        // child.\n        child.use(parent.plugins);\n    }\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n    // resolve any conflict between the parent and child values, and also ensure\n    // proper \"placeholders\" are made on the parent.\n    commit(parent, parentContext, false);\n    parent.ledger.merge(child);\n    parent.emit('child', child);\n    return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param _context -\n * @param node -\n * @param _property -\n * @param parent -\n * @returns boolean\n */\nfunction setParent(child, context, _property, parent) {\n    if (isNode(parent)) {\n        if (child.parent && child.parent !== parent) {\n            child.parent.remove(child);\n        }\n        context.parent = parent;\n        child.resetConfig();\n        !parent.children.includes(child)\n            ? parent.add(child)\n            : child.use(parent.plugins);\n        return true;\n    }\n    if (parent === null) {\n        context.parent = null;\n        return true;\n    }\n    return false;\n}\n/**\n * (node.remove) Removes a child from the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction removeChild(node, context, child) {\n    const childIndex = context.children.indexOf(child);\n    if (childIndex !== -1) {\n        if (child.isSettled)\n            node.disturb();\n        context.children.splice(childIndex, 1);\n        // If an ancestor uses the preserve prop, then we are expected to not remove\n        // our values on this node either, see #53\n        let preserve = undefine(child.props.preserve);\n        let parent = child.parent;\n        while (preserve === undefined && parent) {\n            preserve = undefine(parent.props.preserve);\n            parent = parent.parent;\n        }\n        if (!preserve) {\n            node.calm({\n                name: node.type === 'list' ? childIndex : child.name,\n                value: valueRemoved,\n            });\n        }\n        else {\n            node.calm();\n        }\n        child.parent = null;\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n        child.config._rmn = child;\n    }\n    node.ledger.unmerge(child);\n    return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n * @param context -\n * @param _node -\n * @param callback -\n */\nfunction eachChild(_node, context, callback) {\n    context.children.forEach((child) => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n * @param _node -\n * @param context -\n * @param callback -\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n    context.children.forEach((child) => {\n        if (callback(child) !== false || !stopIfFalse) {\n            child.walk(callback);\n        }\n    });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n * @param node -\n * @param context -\n * @param _property -\n * @param config -\n */\nfunction resetConfig(node, context) {\n    const parent = node.parent || undefined;\n    context.config = createConfig(node.config._t, parent);\n    node.walk((n) => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, it\u2019s children, and executes it.\n * @param context -\n * @param node -\n * @param plugin -\n * @public\n */\nfunction use(node, context, plugin, run = true, library = true) {\n    if (Array.isArray(plugin) || plugin instanceof Set) {\n        plugin.forEach((p) => use(node, context, p));\n        return node;\n    }\n    if (!context.plugins.has(plugin)) {\n        if (library && typeof plugin.library === 'function')\n            plugin.library(node);\n        // When plugins return false, they are never added as to the plugins Set\n        // meaning they only ever have access to the single node they were added on.\n        if (run && plugin(node) !== false) {\n            context.plugins.add(plugin);\n            node.children.forEach((child) => child.use(plugin));\n        }\n    }\n    return node;\n}\n/**\n * Moves a node in the parent\u2019s children to the given index.\n * @param node -\n * @param _context -\n * @param _property -\n * @param setIndex -\n */\nfunction setIndex(node, _context, _property, setIndex) {\n    if (isNode(node.parent)) {\n        const children = node.parent.children;\n        const index = setIndex >= children.length\n            ? children.length - 1\n            : setIndex < 0\n                ? 0\n                : setIndex;\n        const oldIndex = children.indexOf(node);\n        if (oldIndex === -1)\n            return false;\n        children.splice(oldIndex, 1);\n        children.splice(index, 0, node);\n        node.parent.children = children;\n        if (node.parent.type === 'list')\n            node.parent\n                .disturb()\n                .calm({ name: index, value: valueMoved, from: oldIndex });\n        return true;\n    }\n    return false;\n}\n/**\n * Retrieves the index of a node from the parent\u2019s children.\n * @param node -\n */\nfunction getIndex(node) {\n    if (node.parent) {\n        const index = [...node.parent.children].indexOf(node);\n        // If the index is currently -1 then the node isnt finished booting, so it\n        // must be the next node.\n        return index === -1 ? node.parent.children.length : index;\n    }\n    return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n * @param _node -\n * @param context -\n */\nfunction getContext(_node, context) {\n    return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n * @param node -\n * @param context -\n */\nfunction getName(node, context) {\n    var _a;\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return node.index;\n    return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n * @param node -\n * @param context -\n */\nfunction getAddress(node, context) {\n    return context.parent\n        ? context.parent.address.concat([node.name])\n        : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n * @param context -\n * @param node -\n * @param location -\n * @returns FormKitNode\n */\nfunction getNode(node, _context, locator) {\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n    if (!address.length)\n        return undefined;\n    const first = address[0];\n    let pointer = node.parent;\n    if (!pointer) {\n        // This address names the root node, remove it to get child name:\n        if (String(address[0]) === String(node.name))\n            address.shift();\n        // All root nodes start at themselves ultimately:\n        pointer = node;\n    }\n    // Any addresses starting with $parent should discard it\n    if (first === '$parent')\n        address.shift();\n    while (pointer && address.length) {\n        const name = address.shift();\n        switch (name) {\n            case '$root':\n                pointer = node.root;\n                break;\n            case '$parent':\n                pointer = pointer.parent;\n                break;\n            case '$self':\n                pointer = node;\n                break;\n            default:\n                pointer =\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\n                        select(pointer, name);\n        }\n    }\n    return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n * @param node -\n * @param selector -\n * @returns FormKitNode | undefined\n */\nfunction select(node, selector) {\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n    if (matches) {\n        const [, action, argStr] = matches;\n        const args = argStr.split(',').map((arg) => arg.trim());\n        switch (action) {\n            case 'find':\n                return node.find(args[0], args[1]);\n            default:\n                return undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n * @param node - The node to start the search on/under\n * @param _context - The context object\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key to search on, or a function\n * @returns\n */\nfunction find(node, _context, searchTerm, searcher) {\n    return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first-search on a node subtree and locate the first\n * instance of a match.\n * @param node -\n * @param name -\n * @returns FormKitNode\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n    const search = typeof searchGoal === 'string'\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\n        : searchGoal;\n    const stack = [tree];\n    while (stack.length) {\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (search(node, searchValue))\n            return node;\n        stack.push(...node.children);\n    }\n    return undefined;\n}\n/**\n * Get the root node of the tree.\n */\nfunction getRoot(n) {\n    let node = n;\n    while (node.parent) {\n        node = node.parent;\n    }\n    return node;\n}\n/**\n * Creates a new configuration option.\n * @param parent -\n * @param configOptions -\n * @returns FormKitConfig\n */\nfunction createConfig(target = {}, parent) {\n    let node = undefined;\n    return new Proxy(target, {\n        get(...args) {\n            const prop = args[1];\n            if (prop === '_t')\n                return target;\n            const localValue = Reflect.get(...args);\n            // Check our local values first\n            if (localValue !== undefined)\n                return localValue;\n            // Then check our parent values next\n            if (parent) {\n                const parentVal = parent.config[prop];\n                if (parentVal !== undefined)\n                    return parentVal;\n            }\n            if (target.rootConfig && typeof prop === 'string') {\n                const rootValue = target.rootConfig[prop];\n                if (rootValue !== undefined)\n                    return rootValue;\n            }\n            // The default delay value should be 20\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\n                return 20;\n            // Finally check the default values\n            return defaultConfig[prop];\n        },\n        set(...args) {\n            const prop = args[1];\n            const value = args[2];\n            if (prop === '_n') {\n                node = value;\n                if (target.rootConfig)\n                    target.rootConfig._add(node);\n                return true;\n            }\n            if (prop === '_rmn') {\n                if (target.rootConfig)\n                    target.rootConfig._rm(node);\n                node = undefined;\n                return true;\n            }\n            if (!eq(target[prop], value, false)) {\n                const didSet = Reflect.set(...args);\n                if (node) {\n                    node.emit(`config:${prop}`, value, false);\n                    configChange(node, prop, value);\n                    // Walk the node tree and notify of config/prop changes where relevant\n                    node.walk((n) => configChange(n, prop, value), true);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n * @param key - A message key, or generic string of text\n * @returns\n */\nfunction text(node, _context, key, type = 'ui') {\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\n    const value = node.hook.text.dispatch(fragment);\n    node.emit('text', value, false);\n    return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n * @param node - The node to initiate the submit\n */\nfunction submit(node) {\n    const name = node.name;\n    do {\n        if (node.props.isForm === true)\n            break;\n        if (!node.parent)\n            error(106, name);\n        node = node.parent;\n    } while (node);\n    if (node.props.id) {\n        submitForm(node.props.id);\n    }\n}\n/**\n * Reset to the original value.\n * @param node - The node to reset\n * @param _context - The context\n * @param value - The value to reset to\n */\nfunction resetValue(node, _context, value) {\n    return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction setErrors$1(node, _context, localErrors, childErrors) {\n    const sourceKey = `${node.name}-set`;\n    const errors = node.hook.setErrors.dispatch({ localErrors, childErrors });\n    createMessages(node, errors.localErrors, errors.childErrors).forEach((errors) => {\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\n    });\n    return node;\n}\n/**\n * Clears errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction clearErrors$1(node, context, clearChildErrors = true, sourceKey) {\n    setErrors$1(node, context, []);\n    if (clearChildErrors) {\n        sourceKey = sourceKey || `${node.name}-set`;\n        node.walk((child) => {\n            child.store.filter((message) => {\n                return !(message.type === 'error' &&\n                    message.meta &&\n                    message.meta.source === sourceKey);\n            });\n        });\n    }\n    return node;\n}\n/**\n * Middleware to assign default prop values as issued by core.\n * @param node - The node being registered\n * @param next - Calls the next middleware.\n * @returns\n */\nfunction defaultProps(node) {\n    if (!has(node.props, 'id'))\n        node.props.id = `input_${idCount++}`;\n    return node;\n}\n/**\n * @param options -\n * @param config -\n */\nfunction createProps(initial) {\n    const props = {\n        initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n    };\n    let node;\n    let isEmitting = true;\n    return new Proxy(props, {\n        get(...args) {\n            const [_t, prop] = args;\n            if (has(props, prop))\n                return Reflect.get(...args);\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\n                return node.config[prop];\n            return undefined;\n        },\n        set(target, property, originalValue, receiver) {\n            if (property === '_n') {\n                node = originalValue;\n                return true;\n            }\n            if (property === '_emit') {\n                isEmitting = originalValue;\n                return true;\n            }\n            const { prop, value } = node.hook.prop.dispatch({\n                prop: property,\n                value: originalValue,\n            });\n            // Typescript compiler cannot handle a symbol index, even though js can:\n            if (!eq(props[prop], value, false) ||\n                typeof value === 'object') {\n                const didSet = Reflect.set(target, prop, value, receiver);\n                if (isEmitting) {\n                    node.emit('prop', { prop, value });\n                    if (typeof prop === 'string')\n                        node.emit(`prop:${prop}`, value);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n * @param node - A formkit node\n * @param plugins - An array of plugins\n * @returns\n */\nfunction findDefinition(node, plugins) {\n    // If the definition is already there, force call to define.\n    if (node.props.definition)\n        return node.define(node.props.definition);\n    for (const plugin of plugins) {\n        if (node.props.definition)\n            return;\n        if (typeof plugin.library === 'function') {\n            plugin.library(node);\n        }\n    }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n * @param options - An options object to override the defaults.\n * @returns FormKitContext\n */\nfunction createContext(options) {\n    const value = createValue(options);\n    const config = createConfig(options.config || {}, options.parent);\n    return {\n        _d: 0,\n        _e: createEmitter(),\n        _resolve: false,\n        _tmo: false,\n        _value: value,\n        children: dedupe(options.children || []),\n        config,\n        hook: createHooks(),\n        isCreated: false,\n        isSettled: true,\n        ledger: createLedger(),\n        name: createName(options),\n        parent: options.parent || null,\n        plugins: new Set(),\n        props: createProps(value),\n        settled: Promise.resolve(value),\n        store: createStore(true),\n        traps: createTraps(),\n        type: options.type || 'input',\n        value,\n    };\n}\n/**\n * Initialize a node object's internal properties.\n * @param node - The node to initialize\n * @returns FormKitNode\n */\nfunction nodeInit(node, options) {\n    var _a;\n    // Set the internal node on the props, config, ledger and store\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\n    // Apply given in options to the node.\n    node.props._emit = false;\n    if (options.props)\n        Object.assign(node.props, options.props);\n    node.props._emit = true;\n    // Attempt to find a definition from the pre-existing plugins.\n    findDefinition(node, new Set([\n        ...(options.plugins || []),\n        ...(node.parent ? node.parent.plugins : []),\n    ]));\n    // Then we apply each plugin's root code, we do this with an explicit loop\n    // for that ity-bitty performance bump.\n    if (options.plugins) {\n        for (const plugin of options.plugins) {\n            use(node, node._c, plugin, true, false);\n        }\n    }\n    // Initialize the default props\n    defaultProps(node);\n    // Apply the parent to each child.\n    node.each((child) => node.add(child));\n    // If the node has a parent, ensure it's properly nested bi-directionally.\n    if (node.parent)\n        node.parent.add(node, options.index);\n    // Inputs are leafs, and cannot have children\n    if (node.type === 'input' && node.children.length)\n        error(100, node);\n    // Apply the input hook to the initial value.\n    input(node, node._c, node._value, false);\n    // Release the store buffer\n    node.store.release();\n    // Register the node globally if someone explicitly gave it an id\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\n        register(node);\n    // Our node is finally ready, emit it to the world\n    node.emit('created', node);\n    node.isCreated = true;\n    return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of\n * a FormKit graph.\n *\n * @param options - An object of options to define the node.\n * @returns FormKitNode\n * @public\n */\nfunction createNode(options) {\n    const ops = options || {};\n    const context = createContext(ops);\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\n    // force-typing to a FormKitNode. See:\n    // https://github.com/microsoft/TypeScript/issues/28067\n    const node = new Proxy(context, {\n        get(...args) {\n            const [, property] = args;\n            if (property === '__FKNode__')\n                return true;\n            const trap = context.traps.get(property);\n            if (trap && trap.get)\n                return trap.get(node, context);\n            return Reflect.get(...args);\n        },\n        set(...args) {\n            const [, property, value] = args;\n            const trap = context.traps.get(property);\n            if (trap && trap.set)\n                return trap.set(node, context, property, value);\n            return Reflect.set(...args);\n        },\n    });\n    return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isDOM(node) {\n    return typeof node !== 'string' && has(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isComponent(node) {\n    return typeof node !== 'string' && has(node, '$cmp');\n}\n/**\n * Root declaration.\n * @param node - An object to check\n * @returns\n * @public\n */\nfunction isConditional(node) {\n    if (!node || typeof node === 'string')\n        return false;\n    return has(node, 'if') && has(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n * @param node - Node\n * @returns\n * @public\n */\nfunction isSugar(node) {\n    return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n * @param node - A node to covert\n * @returns\n * @public\n */\nfunction sugar(node) {\n    if (typeof node === 'string') {\n        return {\n            $el: 'text',\n            children: node,\n        };\n    }\n    if (isSugar(node)) {\n        const { $formkit: type, for: iterator, if: condition, children, bind, ...props } = node;\n        return Object.assign({\n            $cmp: 'FormKit',\n            props: { ...props, type },\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, bind ? { bind } : {});\n    }\n    return node;\n}\n\n/**\n * Compiles a logical string like \"a != z || b == c\" into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n * @param expr - A string to compile\n * @returns\n * @public\n */\nfunction compile(expr) {\n    /**\n     * These tokens are replacements used in evaluating a given condition.\n     */\n    // const tokens: FormKitTokens = {}\n    /**\n     * The value of the provide() callback. Used for late binding.\n     */\n    let provideTokens;\n    /**\n     * These are token requirements like \"$name.value\" that are need to fulfill\n     * a given condition call.\n     */\n    const requirements = new Set();\n    /**\n     * Expands the current value if it is a function.\n     * @param operand - A left or right hand operand\n     * @returns\n     */\n    const x = function expand(operand, tokens) {\n        return typeof operand === 'function' ? operand(tokens) : operand;\n    };\n    /**\n     * Comprehensive list of operators. This list MUST be\n     * ordered by the length of the operator characters in descending order.\n     */\n    const operatorRegistry = [\n        {\n            '&&': (l, r, t) => x(l, t) && x(r, t),\n            '||': (l, r, t) => x(l, t) || x(r, t),\n        },\n        {\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n        },\n        {\n            '+': (l, r, t) => x(l, t) + x(r, t),\n            '-': (l, r, t) => x(l, t) - x(r, t),\n        },\n        {\n            '*': (l, r, t) => x(l, t) * x(r, t),\n            '/': (l, r, t) => x(l, t) / x(r, t),\n            '%': (l, r, t) => x(l, t) % x(r, t),\n        },\n    ];\n    /**\n     * A full list of all operator symbols.\n     */\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\n        return s.concat(Object.keys(g));\n    }, []);\n    /**\n     * An array of the first character of each operator.\n     */\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\n    /**\n     * Determines if the current character is the start of an operator symbol, if it\n     * is, it returns that symbol.\n     * @param symbols - An array of symbols that are considered operators\n     * @param char - The current character being operated on\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @returns\n     */\n    function getOp(symbols, char, p, expression) {\n        const candidates = symbols.filter((s) => s.startsWith(char));\n        if (!candidates.length)\n            return false;\n        return candidates.find((symbol) => {\n            if (expression.length >= p + symbol.length) {\n                const nextChars = expression.substring(p, p + symbol.length);\n                if (nextChars === symbol)\n                    return symbol;\n            }\n            return false;\n        });\n    }\n    /**\n     * Determines the step number of the right or left hand operator.\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @param direction - 1 = right, 0 = left\n     */\n    function getStep(p, expression, direction = 1) {\n        let next = direction\n            ? expression.substring(p + 1).trim()\n            : expression.substring(0, p).trim();\n        if (!next.length)\n            return -1;\n        if (!direction) {\n            // left hand direction could include a function name we need to remove\n            const reversed = next.split('').reverse();\n            const start = reversed.findIndex((char) => operatorChars.has(char));\n            next = reversed.slice(start).join('');\n        }\n        const char = next[0];\n        return operatorRegistry.findIndex((operators) => {\n            const symbols = Object.keys(operators);\n            return !!getOp(symbols, char, 0, next);\n        });\n    }\n    /**\n     * Extracts a tail call. For example:\n     * ```\n     * $foo().bar(baz) + 7\n     * ```\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n     *\n     * @param p - The position of a closing parenthetical.\n     * @param expression - The full expression being parsed.\n     */\n    function getTail(pos, expression) {\n        let tail = '';\n        const length = expression.length;\n        let depth = 0;\n        for (let p = pos; p < length; p++) {\n            const char = expression.charAt(p);\n            if (char === '(') {\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n            }\n            else if (depth === 0 && char === ' ') {\n                continue;\n            }\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n                return [tail, p - 1];\n            }\n            else {\n                tail += char;\n            }\n        }\n        return [tail, expression.length - 1];\n    }\n    /**\n     * Parse a string expression into a function that returns a boolean. This is\n     * the magic behind schema logic like $if.\n     * @param expression - A string expression to parse\n     * @returns\n     */\n    function parseLogicals(expression, step = 0) {\n        const operators = operatorRegistry[step];\n        const length = expression.length;\n        const symbols = Object.keys(operators);\n        let depth = 0;\n        let quote = false;\n        let op = null;\n        let operand = '';\n        let left = null;\n        let operation;\n        let lastChar = '';\n        let char = '';\n        let parenthetical = '';\n        let parenQuote = '';\n        let startP = 0;\n        const addTo = (depth, char) => {\n            depth ? (parenthetical += char) : (operand += char);\n        };\n        for (let p = 0; p < length; p++) {\n            lastChar = char;\n            char = expression.charAt(p);\n            if ((char === \"'\" || char === '\"') &&\n                lastChar !== '\\\\' &&\n                ((depth === 0 && !quote) || (depth && !parenQuote))) {\n                if (depth) {\n                    parenQuote = char;\n                }\n                else {\n                    quote = char;\n                }\n                addTo(depth, char);\n                continue;\n            }\n            else if ((quote && (char !== quote || lastChar === '\\\\')) ||\n                (parenQuote && (char !== parenQuote || lastChar === '\\\\'))) {\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote === char) {\n                quote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (parenQuote === char) {\n                parenQuote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (char === ' ') {\n                continue;\n            }\n            else if (char === '(') {\n                if (depth === 0) {\n                    startP = p;\n                }\n                else {\n                    parenthetical += char;\n                }\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n                if (depth === 0) {\n                    // Parenthetical statements cannot be grouped up in the implicit order\n                    // of left/right statements based on which step they are on because\n                    // they are parsed on every step and then must be applied to the\n                    // operator. Example:\n                    //\n                    // 5 + (3) * 2\n                    //\n                    // This should yield 11 not 16. This order is normally implicit in the\n                    // sequence of operators being parsed, but with parenthesis the parse\n                    // happens each time. Instead we need to know if the resulting value\n                    // should be applied to the left or the right hand operator. The\n                    // general algorithm is:\n                    //\n                    // 1. Does this paren have an operator on the left or right side\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\n                    // 3. If it does, then which order of operation is highest?\n                    // 4. Wait for the highest order of operation to bind to an operator.\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\n                    // need to subtract the existing operand length from the start\n                    // to determine if this is a left or right operation\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\n                        ? operand\n                        : undefined;\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\n                    // It's possible the function has a chained tail call:\n                    let tail = '';\n                    if (hasTail) {\n                        [tail, p] = getTail(p + 2, expression);\n                    }\n                    const lStep = op ? step : getStep(startP, expression, 0);\n                    const rStep = getStep(p, expression);\n                    if (lStep === -1 && rStep === -1) {\n                        // This parenthetical was unnecessarily wrapped at the root, or\n                        // these are args of a function call.\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n                        // has a left hand operator with a higher order of operation\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n                        op = null;\n                        operand = '';\n                    }\n                    else if (rStep > lStep && step === rStep) {\n                        // should be applied to the right hand operator when it gets one\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else {\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n                    }\n                    parenthetical = '';\n                }\n                else {\n                    parenthetical += char;\n                }\n            }\n            else if (depth === 0 &&\n                (operation = getOp(symbols, char, p, expression))) {\n                if (p === 0) {\n                    error(103, [operation, expression]);\n                }\n                // We identified the operator by looking ahead in the string, so we need\n                // our position to move past the operator\n                p += operation.length - 1;\n                if (p === expression.length - 1) {\n                    error(104, [operation, expression]);\n                }\n                if (!op) {\n                    // Bind the left hand operand\n                    if (left) {\n                        // In this case we've already parsed the left hand operator\n                        op = operators[operation].bind(null, evaluate(left, step));\n                        left = null;\n                    }\n                    else {\n                        op = operators[operation].bind(null, evaluate(operand, step));\n                        operand = '';\n                    }\n                }\n                else if (operand) {\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\n                    left = op.bind(null, evaluate(operand, step));\n                    op = operators[operation].bind(null, left);\n                    operand = '';\n                }\n                continue;\n            }\n            else {\n                addTo(depth, char);\n            }\n        }\n        if (operand && op) {\n            // If we were left with an operand after the loop, and an op, it should\n            // be the right hand assignment.\n            op = op.bind(null, evaluate(operand, step));\n        }\n        // If we don't have an op, but we do have a left hand assignment, then that\n        // is actually our operator, so just re-assign it to op\n        op = !op && left ? left : op;\n        if (!op && operand) {\n            // If we don't have any op but we do have an operand so there is no boolean\n            // logic to perform, but that operand still means something so we need to\n            // evaluate it and return it as a function\n            op = (v, t) => {\n                return typeof v === 'function' ? v(t) : v;\n            };\n            op = op.bind(null, evaluate(operand, step));\n        }\n        if (!op && !operand) {\n            error(105, expression);\n        }\n        return op;\n    }\n    /**\n     * Given a string like '$name==bobby' evaluate it to true or false\n     * @param operand - A left or right boolean operand \u2014 usually conditions\n     * @param step - The current order of operation\n     * @param fnToken - The token (string) representation of a function being called\n     * @returns\n     */\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\n    ) {\n        if (fnToken) {\n            const fn = evaluate(fnToken, operatorRegistry.length);\n            let userFuncReturn;\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\n            // to compile tail calls, and then provide the function result to the\n            // exposed tokens.\n            let tailCall = tail\n                ? compile(`$${tail}`)\n                : false;\n            if (typeof fn === 'function') {\n                const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));\n                return (tokens) => {\n                    const userFunc = fn(tokens);\n                    if (typeof userFunc !== 'function') {\n                        warn(150, fnToken);\n                        return userFunc;\n                    }\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\n                    if (tailCall) {\n                        tailCall = tailCall.provide((subTokens) => {\n                            const rootTokens = provideTokens(subTokens);\n                            const t = subTokens.reduce((tokenSet, token) => {\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                                if (isTail) {\n                                    const value = getAt(userFuncReturn, token);\n                                    tokenSet[token] = () => value;\n                                }\n                                else {\n                                    tokenSet[token] = rootTokens[token];\n                                }\n                                return tokenSet;\n                            }, {});\n                            return t;\n                        });\n                    }\n                    return tailCall ? tailCall() : userFuncReturn;\n                };\n            }\n        }\n        else if (typeof operand === 'string') {\n            // the word true or false will never contain further operations\n            if (operand === 'true')\n                return true;\n            if (operand === 'false')\n                return false;\n            if (operand === 'undefined')\n                return undefined;\n            // Truly quotes strings cannot contain an operation, return the string\n            if (isQuotedString(operand))\n                return rmEscapes(operand.substring(1, operand.length - 1));\n            // Actual numbers cannot be contain an operation\n            if (!isNaN(+operand))\n                return Number(operand);\n            if (step < operatorRegistry.length - 1) {\n                return parseLogicals(operand, step + 1);\n            }\n            else {\n                if (operand.startsWith('$')) {\n                    const cleaned = operand.substring(1);\n                    requirements.add(cleaned);\n                    return function getToken(tokens) {\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\n                    };\n                }\n                // In this case we are dealing with an unquoted string, just treat it\n                // as a plain string.\n                return operand;\n            }\n        }\n        return operand;\n    }\n    /**\n     * Compile the string.\n     */\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\n    /**\n     * Convert compiled requirements to an array.\n     */\n    const reqs = Array.from(requirements);\n    /**\n     * Provides token values via callback to compiled output.\n     * @param callback - A callback that needs to provide all token requirements\n     * @returns\n     */\n    function provide(callback) {\n        provideTokens = callback;\n        return Object.assign(compiled.bind(null, callback(reqs)), {\n            provide,\n        });\n    }\n    return Object.assign(compiled, {\n        provide,\n    });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes\n * @param propertyKey - section key\n * @param node - FormKit node\n * @param sectionClassList - Things to turn into classes\n * @returns\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n    if (!sectionClassList)\n        return {};\n    if (typeof sectionClassList === 'string') {\n        const classKeys = sectionClassList.split(' ');\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\n    }\n    else if (typeof sectionClassList === 'function') {\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n    }\n    return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list\n * @param node - the FormKit node being operated on\n * @param property - The property key to which the class list will be applied\n * @param args - CSS class list(s)\n * @returns\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n        if (!currentClassList)\n            return finalClassList;\n        const { $reset, ...classList } = currentClassList;\n        if ($reset) {\n            return classList;\n        }\n        return Object.assign(finalClassList, classList);\n    }, {});\n    return (Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\n        .classes)\n        .filter((key) => combinedClassList[key])\n        .join(' ') || null);\n}\n\n/**\n * Sets errors on a form, group, or input.\n * @param formId - The id of a form\n * @param localErrors - The errors to set on the form or the form\u2019s inputs\n * @param childErrors - (optional) The errors to set on the form or the form\u2019s inputs\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n    const node = getNode$1(id);\n    if (node) {\n        node.setErrors(localErrors, childErrors);\n    }\n    else {\n        warn(651, id);\n    }\n}\n/**\n * Clears child errors.\n * @param id - The id of the node you want to clear errors for\n * @param clearChildren - Determines if the the children of this node should have their errors cleared.\n * @public\n */\nfunction clearErrors(id, clearChildren = true) {\n    const node = getNode$1(id);\n    if (node) {\n        node.clearErrors(clearChildren);\n    }\n    else {\n        warn(652, id);\n    }\n}\n\n/**\n * index.ts\n *\n * In this file we explicitly declare what should end up in the public API.\n */\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n * @public\n */\nconst FORMKIT_VERSION = '1.0.0-beta.11';\n\nexport { FORMKIT_VERSION, bfs, clearErrors, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueInserted, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };\n", "import { extend, camel, has, isPojo, eq, kebab, undefine, clone, isObject } from '@formkit/utils';\nimport { createMessage, warn, isConditional, isDOM, isComponent } from '@formkit/core';\n\n/**\n *\n * @param libraries - One or many formkit urls.\n * @returns\n * @public\n */\nfunction createLibraryPlugin(...libraries) {\n    /**\n     * Merge all provided library items.\n     */\n    const library = libraries.reduce((merged, lib) => extend(merged, lib), {});\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    const plugin = () => { };\n    /**\n     * Enables the hook that exposes all library inputs.\n     * @param node - The primary plugin\n     */\n    plugin.library = function (node) {\n        const type = camel(node.props.type);\n        if (has(library, type)) {\n            node.define(library[type]);\n        }\n    };\n    return plugin;\n}\n\n/**\n * Accepts an array of objects, array of strings, or object of key-value pairs.\n * and returns an array of objects with value and label properties.\n * @param options - Options to normalize\n * @public\n */\nfunction normalizeOptions(options) {\n    let i = 1;\n    if (Array.isArray(options)) {\n        return options.map((option) => {\n            if (typeof option === 'string' || typeof option === 'number') {\n                return {\n                    label: String(option),\n                    value: String(option),\n                };\n            }\n            if (typeof option == 'object') {\n                if ('value' in option && typeof option.value !== 'string') {\n                    Object.assign(option, {\n                        value: `__mask_${i++}`,\n                        __original: option.value,\n                    });\n                }\n            }\n            return option;\n        });\n    }\n    return Object.keys(options).map((value) => {\n        return {\n            label: options[value],\n            value,\n        };\n    });\n}\n/**\n * Given an option list, find the \"true\" value in the options.\n * @param options - The options to check for a given value\n * @param value - The value to return\n * @returns\n */\nfunction optionValue(options, value) {\n    if (Array.isArray(options)) {\n        for (const option of options) {\n            if (value == option.value) {\n                return '__original' in option ? option.__original : option.value;\n            }\n        }\n    }\n    return value;\n}\n/**\n * Determines if the value should be selected.\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n */\nfunction shouldSelect(valueA, valueB) {\n    if (valueA == valueB)\n        return true;\n    if (isPojo(valueA) && isPojo(valueB))\n        return eq(valueA, valueB);\n    return false;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction options(node) {\n    node.hook.prop((prop, next) => {\n        if (prop.prop === 'options') {\n            if (typeof prop.value === 'function') {\n                node.props.optionsLoader = prop.value;\n                prop.value = [];\n            }\n            else {\n                prop.value = normalizeOptions(prop.value);\n            }\n        }\n        return next(prop);\n    });\n}\n\n/**\n * @public\n */\nconst outer = createSection('outer', () => ({\n    $el: 'div',\n    attrs: {\n        key: '$id',\n        'data-family': '$family || undefined',\n        'data-type': '$type',\n        'data-multiple': '$attrs.multiple || ($type != \"select\" && $options != undefined) || undefined',\n        'data-disabled': '$disabled || undefined',\n        'data-complete': '$state.complete || undefined',\n        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',\n        'data-errors': '$state.errors || undefined',\n        'data-submitted': '$state.submitted || undefined',\n        'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\n        'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\n        'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\n        'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\n    },\n}), true);\n\n/**\n * @public\n */\nconst inner = createSection('inner', 'div');\n\n/**\n * @public\n */\nconst wrapper = createSection('wrapper', 'div');\n\n/**\n * @public\n */\nconst label = createSection('label', () => ({\n    $el: 'label',\n    if: '$label',\n    attrs: {\n        for: '$id',\n    },\n}));\n\n/**\n * @public\n */\nconst messages = createSection('messages', () => ({\n    $el: 'ul',\n    if: '$fns.length($messages)',\n}));\n\n/**\n * @public\n */\nconst message = createSection('message', () => ({\n    $el: 'li',\n    for: ['message', '$messages'],\n    attrs: {\n        key: '$message.key',\n        id: `$id + '-' + $message.key`,\n        'data-message-type': '$message.type',\n    },\n}));\n\n/**\n * @public\n */\nconst prefix = createSection('prefix', null);\n\n/**\n * @public\n */\nconst suffix = createSection('suffix', null);\n\n/**\n * @public\n */\nconst help = createSection('help', () => ({\n    $el: 'div',\n    if: '$help',\n    attrs: {\n        id: '$: \"help-\" + $id',\n    },\n}));\n\n/**\n * @public\n */\nconst fieldset = createSection('fieldset', () => ({\n    $el: 'fieldset',\n    attrs: {\n        id: '$id',\n        'aria-describedby': {\n            if: '$help',\n            then: '$: \"help-\" + $id',\n            else: undefined,\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst decorator = createSection('decorator', () => ({\n    $el: 'span',\n    attrs: {\n        'aria-hidden': 'true',\n    },\n}));\n\n/**\n * @public\n */\nconst box = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        name: '$node.props.altName || $node.name',\n        disabled: '$option.attrs.disabled || $disabled',\n        onInput: '$handlers.toggleChecked',\n        checked: '$fns.eq($_value, $onValue)',\n        onBlur: '$handlers.blur',\n        value: '$: true',\n        id: '$id',\n        'aria-describedby': {\n            if: '$options.length',\n            then: {\n                if: '$option.help',\n                then: '$: \"help-\" + $option.attrs.id',\n                else: undefined,\n            },\n            else: {\n                if: '$help',\n                then: '$: \"help-\" + $id',\n                else: undefined,\n            },\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst legend = createSection('legend', () => ({\n    $el: 'legend',\n    if: '$label',\n}));\n\n/**\n * @public\n */\nconst boxOption = createSection('option', () => ({\n    $el: 'li',\n    for: ['option', '$options'],\n    attrs: {\n        'data-disabled': '$option.attrs.disabled || $disabled',\n    },\n}));\n\n/**\n * @public\n */\nconst boxOptions = createSection('options', 'ul');\n\n/**\n * @public\n */\nconst boxWrapper = createSection('wrapper', () => ({\n    $el: 'label',\n    attrs: {\n        'data-disabled': {\n            if: '$options.length',\n            then: undefined,\n            else: '$disabled || undefined',\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst boxHelp = createSection('optionHelp', () => ({\n    $el: 'div',\n    if: '$option.help',\n    attrs: {\n        id: '$: \"help-\" + $option.attrs.id',\n    },\n}));\n\n/**\n * @public\n */\nconst boxLabel = createSection('label', 'span');\n\n/**\n * @public\n */\nconst buttonInput = createSection('input', () => ({\n    $el: 'button',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        name: '$node.name',\n        id: '$id',\n    },\n}));\n\n/**\n * @public\n */\nconst buttonLabel = createSection('default', null);\n\n/**\n * @public\n */\nconst fileInput = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: 'file',\n        disabled: '$disabled',\n        name: '$node.name',\n        onChange: '$handlers.files',\n        onBlur: '$handlers.blur',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst fileItem = createSection('fileItem', () => ({\n    $el: 'li',\n    for: ['file', '$value'],\n}));\n\n/**\n * @public\n */\nconst fileList = createSection('fileList', () => ({\n    $el: 'ul',\n    if: '$value.length',\n    attrs: {\n        'data-has-multiple': {\n            if: '$value.length > 1',\n            then: 'true',\n        },\n    },\n}));\n\n/**\n * @public\n */\nconst fileName = createSection('fileName', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.fileName',\n    },\n}));\n\n/**\n * @public\n */\nconst fileRemove = createSection('fileRemove', () => ({\n    $el: 'button',\n    attrs: {\n        onClick: '$handlers.resetFiles',\n    },\n}));\n\n/**\n * @public\n */\nconst noFiles = createSection('noFiles', () => ({\n    $el: 'span',\n    if: '$value.length == 0',\n}));\n\n/**\n * @public\n */\nconst formInput = createSection('form', () => ({\n    $el: 'form',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        name: '$node.name',\n        onSubmit: '$handlers.submit',\n        'data-loading': '$state.loading || undefined',\n    },\n}), true);\n\n/**\n * @public\n */\nconst actions = createSection('actions', () => ({\n    $el: 'div',\n    if: '$actions',\n}));\n\n/**\n * @public\n */\nconst submitInput = createSection('submit', () => ({\n    $cmp: 'FormKit',\n    bind: '$submitAttrs',\n    props: {\n        ignore: true,\n        type: 'submit',\n        disabled: '$disabled',\n        label: '$submitLabel',\n    },\n}));\n\n/**\n * @public\n */\nconst textInput = createSection('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst fragment = createSection('wrapper', null, true);\n\n/**\n * @public\n */\nconst selectInput$1 = createSection('input', () => ({\n    $el: 'select',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        'data-placeholder': {\n            if: '$placeholder',\n            then: {\n                if: '$value',\n                then: undefined,\n                else: 'true',\n            },\n        },\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onChange: '$handlers.onChange',\n        onInput: '$handlers.selectInput',\n        onBlur: '$handlers.blur',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * @public\n */\nconst option = createSection('option', () => ({\n    $el: 'option',\n    for: ['option', '$options'],\n    bind: '$option.attrs',\n    attrs: {\n        class: '$classes.option',\n        value: '$option.value',\n        selected: '$fns.isSelected($option.value)',\n    },\n}));\n\n/**\n * @public\n */\nconst optionSlot = () => ({\n    $el: null,\n    if: '$options.length',\n    for: ['option', '$options'],\n    children: '$slots.option',\n});\n\n/**\n * @public\n */\nconst textareaInput = createSection('input', () => ({\n    $el: 'textarea',\n    bind: '$attrs',\n    attrs: {\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n    children: '$initialValue',\n}));\n\n/**\n * @public\n */\nconst icon = (sectionKey, el) => {\n    return createSection(`${sectionKey}Icon`, () => {\n        const rawIconProp = `_raw${sectionKey\n            .charAt(0)\n            .toUpperCase()}${sectionKey.slice(1)}Icon`;\n        return {\n            if: `$${sectionKey}Icon && $${rawIconProp}`,\n            $el: `${el ? el : 'span'}`,\n            attrs: {\n                class: `$classes.${sectionKey}Icon + \" formkit-icon\"`,\n                innerHTML: `$${rawIconProp}`,\n                onClick: `$handlers.iconClick(${sectionKey})`,\n                for: {\n                    if: `${el === 'label'}`,\n                    then: '$id',\n                },\n            },\n        };\n    })();\n};\n\n/**\n * Normalize the boxes.\n * @param node - The node\n * @returns\n * @public\n */\nfunction normalizeBoxes(node) {\n    return function (prop, next) {\n        if (prop.prop === 'options' && Array.isArray(prop.value)) {\n            prop.value = prop.value.map((option) => {\n                var _a;\n                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {\n                    return extend(option, {\n                        attrs: { id: `${node.name}-option-${kebab(String(option.value))}` },\n                    });\n                }\n                return option;\n            });\n            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n                if (node.isCreated) {\n                    node.input([], false);\n                }\n                else {\n                    node.on('created', () => {\n                        if (!Array.isArray(node.value)) {\n                            node.input([], false);\n                        }\n                    });\n                }\n            }\n        }\n        return next(prop);\n    };\n}\n\n/**\n * Event handler when an input is toggled.\n * @param node - The node being toggled\n * @param e - The input even related to the toggling\n * @public\n */\nfunction toggleChecked$1(node, e) {\n    const el = e.target;\n    if (el instanceof HTMLInputElement) {\n        const value = Array.isArray(node.props.options)\n            ? optionValue(node.props.options, el.value)\n            : el.value;\n        if (Array.isArray(node.props.options) && node.props.options.length) {\n            if (!Array.isArray(node._value)) {\n                // There is no array value set\n                node.input([value]);\n            }\n            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {\n                // The value is not in the current set\n                node.input([...node._value, value]);\n            }\n            else {\n                // Filter out equivalent values\n                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));\n            }\n        }\n        else {\n            if (el.checked) {\n                node.input(node.props.onValue);\n            }\n            else {\n                node.input(node.props.offValue);\n            }\n        }\n    }\n}\n/**\n * Checks if a given option is present in the node value.\n * @param node - The node being checked\n * @param value - The value of any option\n * @returns\n */\nfunction isChecked$1(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    if (Array.isArray(node._value)) {\n        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));\n    }\n    return false;\n}\n/**\n * Adds checkbox selection support\n * @param node - Node the feature is added to\n * @public\n */\nfunction checkboxes(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked$1.bind(null, node);\n        }\n        // Configure our default onValue and offValue\n        if (!has(node.props, 'onValue'))\n            node.props.onValue = true;\n        if (!has(node.props, 'offValue'))\n            node.props.offValue = false;\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Allows disabling children of this.\n * @param node - The FormKitNode of the form/group/list\n * @public\n */\nfunction disables(node) {\n    node.on('created', () => {\n        node.props.disabled = undefine(node.props.disabled);\n    });\n    node.hook.prop(({ prop, value }, next) => {\n        value = prop === 'disabled' ? undefine(value) : value;\n        return next({ prop, value });\n    });\n    node.on('prop:disabled', ({ payload: value }) => {\n        node.config.disabled = undefine(value);\n    });\n    node.on('created', () => {\n        node.config.disabled = undefine(node.props.disabled);\n    });\n}\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message\n * @param value - The value of the message\n * @returns\n * @public\n */\nfunction localize(key, value) {\n    return (node) => {\n        node.store.set(createMessage({\n            key,\n            type: 'ui',\n            value: value || key,\n            meta: {\n                localize: true,\n                i18nArgs: [node],\n            },\n        }));\n    };\n}\n\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Remove the data-file-hover attribute from the target.\n * @param e - Event\n */\nfunction removeHover(e) {\n    if (e.target instanceof HTMLElement &&\n        e.target.hasAttribute('data-file-hover')) {\n        e.target.removeAttribute('data-file-hover');\n    }\n}\n/**\n * Prevent stray drag/drop events from navigating the window.\n * @param e - Event\n * @public\n */\nfunction preventStrayDrop(type, e) {\n    if (!(e.target instanceof HTMLInputElement)) {\n        e.preventDefault();\n    }\n    else if (type === 'dragover') {\n        e.target.setAttribute('data-file-hover', 'true');\n    }\n    if (type === 'drop') {\n        removeHover(e);\n    }\n}\n/**\n * Feature to add file handling support to an input.\n * @param node - The node being checked\n * @public\n */\nfunction files(node) {\n    // Localize our content:\n    localize('noFiles', 'Select file')(node);\n    localize('removeAll', 'Remove all')(node);\n    localize('remove')(node);\n    if (isBrowser) {\n        if (!window._FormKit_File_Drop) {\n            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));\n            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));\n            window.addEventListener('dragleave', removeHover);\n            window._FormKit_File_Drop = true;\n        }\n    }\n    node.hook.input((value, next) => next(Array.isArray(value) ? value : []));\n    node.on('created', () => {\n        if (!Array.isArray(node.value))\n            node.input([], false);\n        if (!node.context)\n            return;\n        node.context.handlers.resetFiles = (e) => {\n            e.preventDefault();\n            node.input([]);\n            if (node.props.id && isBrowser) {\n                const el = document.getElementById(node.props.id);\n                if (el)\n                    el.value = '';\n            }\n        };\n        node.context.handlers.files = (e) => {\n            var _a, _b;\n            const files = [];\n            if (e.target instanceof HTMLInputElement && e.target.files) {\n                for (let i = 0; i < e.target.files.length; i++) {\n                    let file;\n                    if ((file = e.target.files.item(i))) {\n                        files.push({ name: file.name, file });\n                    }\n                }\n                node.input(files);\n            }\n            if (node.context)\n                node.context.files = files;\n            // Call the original listener if there is one.\n            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\n                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);\n            }\n        };\n    });\n}\n\n/**\n * Handle the submit event.\n * @param e - The event\n * @public\n */\nasync function handleSubmit(node, submitEvent) {\n    submitEvent.preventDefault();\n    await node.settled;\n    // Set the submitted state on all children\n    node.walk((n) => {\n        n.store.set(createMessage({\n            key: 'submitted',\n            value: true,\n            visible: false,\n        }));\n    });\n    if (typeof node.props.onSubmitRaw === 'function') {\n        node.props.onSubmitRaw(submitEvent, node);\n    }\n    if (node.ledger.value('blocking')) {\n        if (typeof node.props.onSubmitInvalid === 'function') {\n            node.props.onSubmitInvalid(node);\n        }\n        // There is still a blocking message in the store.\n        if (node.props.incompleteMessage !== false) {\n            node.store.set(createMessage({\n                blocking: false,\n                key: `incomplete`,\n                meta: {\n                    localize: node.props.incompleteMessage === undefined,\n                    i18nArgs: [{ node }],\n                    showAsMessage: true,\n                },\n                type: 'ui',\n                value: node.props.incompleteMessage || 'Form incomplete.',\n            }));\n        }\n    }\n    else {\n        // No blocking messages\n        if (typeof node.props.onSubmit === 'function') {\n            // call onSubmit\n            const retVal = node.props.onSubmit(node.hook.submit.dispatch(clone(node.value)), node);\n            if (retVal instanceof Promise) {\n                const autoDisable = node.props.disabled === undefined &&\n                    node.props.submitBehavior !== 'live';\n                if (autoDisable)\n                    node.props.disabled = true;\n                node.store.set(createMessage({\n                    key: 'loading',\n                    value: true,\n                    visible: false,\n                }));\n                await retVal;\n                if (autoDisable)\n                    node.props.disabled = false;\n                node.store.remove('loading');\n            }\n        }\n        else {\n            if (submitEvent.target instanceof HTMLFormElement) {\n                submitEvent.target.submit();\n            }\n        }\n    }\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction form$1(node) {\n    node.props.isForm = true;\n    node.on('created', () => {\n        var _a;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.submit = handleSubmit.bind(null, node);\n        }\n        if (!has(node.props, 'actions')) {\n            node.props.actions = true;\n        }\n    });\n    node.on('settled:blocking', () => node.store.remove('incomplete'));\n}\n\n/**\n * Applies ignore=\"true\" by default.\n * @param node - The node\n * @public\n */\nfunction ignore(node) {\n    if (node.props.ignore === undefined) {\n        node.props.ignore = true;\n        node.parent = null;\n    }\n}\n\n/**\n * Ensures the input has an `initialValue` prop.\n * @param node - The node being given an initial value\n * @public\n */\nfunction initialValue(node) {\n    node.on('created', () => {\n        if (node.context) {\n            node.context.initialValue = node.value || '';\n        }\n    });\n}\n\n/**\n * Sets the value of a radio button when checked.\n * @param node - FormKitNode\n * @param value - Value\n * @public\n */\nfunction toggleChecked(node, event) {\n    if (event.target instanceof HTMLInputElement) {\n        node.input(optionValue(node.props.options, event.target.value));\n    }\n}\n/**\n * Checks if the value being checked is the current value.\n * @param node - The node to check against.\n * @param value - The value to check\n * @returns\n */\nfunction isChecked(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    return shouldSelect(optionValue(node.props.options, value), node._value);\n}\n/**\n * Determines if a given radio input is being evaluated.\n * @param node - The radio input group.\n * @public\n */\nfunction radios(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if (!Array.isArray(node.props.options)) {\n            warn(350, node);\n        }\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked.bind(null, node);\n        }\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n * @public\n */\nfunction isSelected(node, option) {\n    // Here we trick reactivity (if at play) to watch this function.\n    node.context && node.context.value;\n    const value = optionValue(node.props.options, option);\n    return Array.isArray(node._value)\n        ? node._value.some((optionA) => shouldSelect(optionA, value))\n        : (node.value === undefined && !option) || shouldSelect(value, node._value);\n}\n/**\n * Defers the change event till after the next cycle.\n * @param node - The node being evaluated.\n * @param e - The change event.\n */\nasync function deferChange(node, e) {\n    var _a;\n    if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\n        await new Promise((r) => setTimeout(r, 0));\n        await node.settled;\n        node.props.attrs.onChange(e);\n    }\n}\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction selectInput(node, e) {\n    const target = e.target;\n    const value = target.hasAttribute('multiple')\n        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))\n        : optionValue(node.props.options, target.value);\n    node.input(value);\n}\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options, placeholder) {\n    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {\n        return [\n            {\n                label: placeholder,\n                value: '',\n                attrs: {\n                    hidden: true,\n                    disabled: true,\n                    'data-is-placeholder': 'true',\n                },\n            },\n            ...options,\n        ];\n    }\n    return options;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction select$1(node) {\n    // Set the initial value of a multi-input\n    node.on('created', () => {\n        var _a, _b, _c;\n        const isMultiple = undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);\n        if (!isMultiple &&\n            node.props.placeholder &&\n            Array.isArray(node.props.options)) {\n            node.hook.prop(({ prop, value }, next) => {\n                if (prop === 'options') {\n                    value = applyPlaceholder(value, node.props.placeholder);\n                }\n                return next({ prop, value });\n            });\n            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);\n        }\n        if (isMultiple) {\n            if (node.value === undefined) {\n                node.input([], false);\n            }\n        }\n        else if (node.context && !node.context.options) {\n            // If this input is (probably) using the default slot, we need to add a\n            // \"value\" attribute to get bound\n            node.props.attrs = Object.assign({}, node.props.attrs, {\n                value: node._value,\n            });\n            node.on('input', ({ payload }) => {\n                node.props.attrs = Object.assign({}, node.props.attrs, {\n                    value: payload,\n                });\n            });\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {\n            node.context.handlers.selectInput = selectInput.bind(null, node);\n            node.context.handlers.onChange = deferChange.bind(null, node);\n        }\n        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {\n            node.context.fns.isSelected = isSelected.bind(null, node);\n        }\n    });\n    node.hook.input((value, next) => {\n        var _a, _b, _c;\n        if (!node.props.placeholder &&\n            value === undefined &&\n            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&\n            node.props.options.length &&\n            !undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {\n            value =\n                '__original' in node.props.options[0]\n                    ? node.props.options[0].__original\n                    : node.props.options[0].value;\n        }\n        return next(value);\n    });\n}\n\n/**\n * @param sectionKey - the location the icon should be loaded\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS\n * @public\n */\nfunction defaultIcon(sectionKey, defaultIcon) {\n    return (node) => {\n        if (node.props[`${sectionKey}Icon`] === undefined) {\n            node.props[`${sectionKey}Icon`] = `default:${defaultIcon}`;\n        }\n    };\n}\n\n/**\n * Type guard for schema objects.\n * @param schema - returns true if the node is a schema node but not a string or conditional.\n * @public\n */\nfunction isSchemaObject(schema) {\n    return (typeof schema === 'object' &&\n        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));\n}\n/**\n * Checks if the current schema node is a slot condition like:\n * ```js\n * {\n *  if: '$slot.name',\n *  then: '$slot.name',\n *  else: []\n * }\n * ```\n * @param node - a schema node\n * @returns\n * @public\n */\nfunction isSlotCondition(node) {\n    if (isConditional(node) &&\n        node.if &&\n        node.if.startsWith('$slots.') &&\n        typeof node.then === 'string' &&\n        node.then.startsWith('$slots.') &&\n        'else' in node) {\n        return true;\n    }\n    return false;\n}\n/**\n * Extends a single schema node with an extension. The extension can be any partial node including strings.\n * @param schema - Extend a base schema node.\n * @param extension - The values to extend on the base schema node.\n * @returns\n * @public\n */\nfunction extendSchema(schema, extension = {}) {\n    if (typeof schema === 'string') {\n        return isSchemaObject(extension) || typeof extension === 'string'\n            ? extension\n            : schema;\n    }\n    else if (Array.isArray(schema)) {\n        return isSchemaObject(extension) ? extension : schema;\n    }\n    return extend(schema, extension);\n}\n/**\n * ================================================================\n * NOTE: This function is deprecated. Use `createSection` instead!\n * ================================================================\n *\n * @param key - A new section key name.\n * @param schema - The default schema in this composable slot.\n * @returns\n * @public\n */\nfunction composable(key, schema) {\n    warn(800, 'composable function');\n    return (extendWith = {}, children = undefined) => {\n        const root = typeof schema === 'function'\n            ? schema(children)\n            : typeof schema === 'object'\n                ? clone(schema)\n                : schema;\n        const isObj = isSchemaObject(root);\n        if (isObj && !('children' in root) && children) {\n            if (Array.isArray(children)) {\n                if (children.length) {\n                    root.children = children;\n                }\n            }\n            else {\n                root.children = [children];\n            }\n        }\n        const extended = extendSchema(root, extendWith);\n        return {\n            if: `$slots.${key}`,\n            then: `$slots.${key}`,\n            else: Array.isArray(extended) ? extended : [extended],\n        };\n    };\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n * @param inputSchema - Content to store in the input section key location.\n * @public\n */\nfunction useSchema(inputSection) {\n    return outer(wrapper(label('$label'), inner(prefix(), inputSection(), suffix())), help('$help'), messages(message('$message.value')));\n}\n/**\n * Creates a new reusable section.\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When true returns an extendable root schema node.\n * @returns\n * @public\n */\nfunction createSection(section, el, root = false) {\n    return (...children) => {\n        const extendable = (extensions) => {\n            const node = !el || typeof el === 'string' ? { $el: el } : el();\n            if (isDOM(node) || isComponent(node)) {\n                if (!node.meta) {\n                    node.meta = { section };\n                }\n                if (children.length && !node.children) {\n                    node.children = [\n                        ...children.map((child) => typeof child === 'string' ? child : child(extensions)),\n                    ];\n                }\n                if (isDOM(node)) {\n                    node.attrs = {\n                        class: `$classes.${section}`,\n                        ...(node.attrs || {}),\n                    };\n                }\n            }\n            return {\n                if: `$slots.${section}`,\n                then: `$slots.${section}`,\n                else: section in extensions\n                    ? extendSchema(node, extensions[section])\n                    : node,\n            };\n        };\n        return root ? createRoot(extendable) : extendable;\n    };\n}\n/**\n * Returns an extendable schema root node.\n * @param rootSection - Creates the root node.\n * @returns\n */\nfunction createRoot(rootSection) {\n    return (extensions) => {\n        return [rootSection(extensions)];\n    };\n}\n/**\n * Applies attributes to a given schema section by applying a higher order\n * function that merges a given set of attributes into the node.\n * @param attrs - Apply attributes to a FormKitSchemaExtendableSection\n * @param section - A section to apply attributes to\n * @returns\n * @public\n */\nfunction $attrs(attrs, section) {\n    return (extensions) => {\n        const node = section(extensions);\n        const attributes = typeof attrs === 'function' ? attrs() : attrs;\n        if (!isObject(attributes))\n            return node;\n        if (isSlotCondition(node) && isDOM(node.else)) {\n            node.else.attrs = { ...node.else.attrs, ...attributes };\n        }\n        else if (isDOM(node)) {\n            node.attrs = { ...node.attrs, ...attributes };\n        }\n        return node;\n    };\n}\n/**\n *\n * @param condition - A schema condition to apply to a section.\n * @param then - The section that applies if the condition is true.\n * @param otherwise - (else) The section that applies if the condition is false.\n * @returns\n * @public\n */\nfunction $if(condition, then, otherwise) {\n    return (extensions) => {\n        const node = then(extensions);\n        if (otherwise ||\n            (isSchemaObject(node) && 'if' in node) ||\n            isSlotCondition(node)) {\n            const conditionalNode = {\n                if: condition,\n                then: node,\n            };\n            if (otherwise) {\n                conditionalNode.else = otherwise(extensions);\n            }\n            return conditionalNode;\n        }\n        else if (isSlotCondition(node)) {\n            Object.assign(node.else, { if: condition });\n        }\n        else if (isSchemaObject(node)) {\n            Object.assign(node, { if: condition });\n        }\n        return node;\n    };\n}\n/**\n * Applies a condition to a given schema section.\n * @param varName - The name of the variable that holds the current instance.\n * @param inName - The variable we are iterating over.\n * @param section - A section to repeat\n * @returns\n * @public\n */\nfunction $for(varName, inName, section) {\n    return (extensions) => {\n        const node = section(extensions);\n        if (isSlotCondition(node)) {\n            Object.assign(node.else, { for: [varName, inName] });\n        }\n        else if (isSchemaObject(node)) {\n            Object.assign(node, { for: [varName, inName] });\n        }\n        return node;\n    };\n}\n/**\n * Extends a schema node with a given set of extensions.\n * @param section - A section to apply an extension to.\n * @param extendWith - A partial schema snippet to apply to the section.\n * @returns\n * @public\n */\nfunction $extend(section, extendWith) {\n    return (extensions) => {\n        const node = section({});\n        if (isSlotCondition(node)) {\n            if (Array.isArray(node.else))\n                return node;\n            node.else = extendSchema(extendSchema(node.else, extendWith), extensions);\n            return node;\n        }\n        return extendSchema(extendSchema(node, extendWith), extensions);\n    };\n}\n/**\n * Creates a root schema section.\n * @param section - A section to make a root from.\n * @returns\n * @public\n */\nfunction $root(section) {\n    return createRoot(section);\n}\n\n/**\n * Input definition for a button.\n * @public\n */\nconst button = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(messages(message('$message.value')), wrapper(buttonInput(icon('prefix'), prefix(), buttonLabel('$label || $ui.submit.value'), suffix(), icon('suffix'))), help('$help')),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\n     * are both part of the \"text\" family. This is primary used for styling.\n     */\n    family: 'button',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [localize('submit'), ignore],\n};\n\n/**\n * Input definition for a checkbox(ess).\n * @public\n */\nconst checkbox = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer($if('$options == undefined', \n    /**\n     * Single checkbox structure.\n     */\n    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $if('$label', boxLabel('$label'))), \n    /**\n     * Multi checkbox structure.\n     */\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\n        bind: '$option.attrs',\n        attrs: {\n            id: '$option.attrs.id',\n            value: '$option.value',\n            checked: '$fns.isChecked($option.value)',\n        },\n    }), decorator(icon('decorator')), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), \n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', help('$help')), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\n     * are both part of the \"text\" family. This is primary used for styling.\n     */\n    family: 'box',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [\n        options,\n        checkboxes,\n        defaultIcon('decorator', 'checkboxDecorator'),\n    ],\n};\n\n/**\n * Input definition for a file input.\n * @public\n */\nconst file = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), fileInput(), fileList(fileItem(icon('fileItem'), fileName('$file.name'), $if('$value.length === 1', fileRemove(icon('fileRemove'), '$ui.remove.value')))), $if('$value.length > 1', fileRemove('$ui.removeAll.value')), noFiles(icon('noFiles'), '$ui.noFiles.value'), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\n     * are both part of the \"text\" family. This is primary used for styling.\n     */\n    family: 'text',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [\n        files,\n        defaultIcon('fileItem', 'fileItem'),\n        defaultIcon('fileRemove', 'fileRemove'),\n        defaultIcon('noFiles', 'noFiles'),\n    ],\n};\n\n/**\n * Input definition for a form.\n * @public\n */\nconst form = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: formInput('$slots.default', messages(message('$message.value')), actions(submitInput())),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'group',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [\n        'actions',\n        'submit',\n        'submitLabel',\n        'submitAttrs',\n        'submitBehavior',\n        'incompleteMessage',\n    ],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [form$1, disables],\n};\n\n/**\n * Input definition for a group.\n * @public\n */\nconst group = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: fragment('$slots.default'),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'group',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [disables],\n};\n\n/**\n * Input definition for a hidden input.\n * @public\n */\nconst hidden = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: $root(textInput()),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [],\n};\n\n/**\n * Input definition for a list.\n * @public\n */\nconst list = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: fragment('$slots.default'),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'list',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [disables],\n};\n\n/**\n * Input definition for a radio.\n * @public\n */\nconst radio = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer($if('$options == undefined', \n    /**\n     * Single radio structure.\n     */\n    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $if('$label', boxLabel('$label'))), \n    /**\n     * Multi radio structure.\n     */\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\n        bind: '$option.attrs',\n        attrs: {\n            id: '$option.attrs.id',\n            value: '$option.value',\n            checked: '$fns.isChecked($option.value)',\n        },\n    }), decorator(icon('decorator')), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), \n    // Help text only goes under the input when it is a single.\n    $if('$options === undefined && $help', help('$help')), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\n     * are both part of the \"text\" family. This is primary used for styling.\n     */\n    family: 'box',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [options, radios, defaultIcon('decorator', 'radioDecorator')],\n};\n\n/**\n * Input definition for a select.\n * @public\n */\nconst select = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix'), prefix(), selectInput$1($if('$slots.default', () => '$slots.default', $if('$slots.option', optionSlot, option('$option.label')))), $if('$attrs.multiple !== undefined', () => '', icon('select')), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: ['options', 'placeholder', 'optionsLoader'],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [options, select$1, defaultIcon('select', 'select')],\n};\n\n/**\n * Input definition for a textarea.\n * @public\n */\nconst textarea = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textareaInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [initialValue],\n};\n\n/**\n * Input definition for a text.\n * @public\n */\nconst text = {\n    /**\n     * The actual schema of the input, or a function that returns the schema.\n     */\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\n    /**\n     * The type of node, can be a list, group, or input.\n     */\n    type: 'input',\n    /**\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\n     * are both part of the \"text\" family. This is primary used for styling.\n     */\n    family: 'text',\n    /**\n     * An array of extra props to accept for this input.\n     */\n    props: [],\n    /**\n     * Additional features that should be added to your input\n     */\n    features: [],\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    button: button,\n    submit: button,\n    checkbox: checkbox,\n    file: file,\n    form: form,\n    group: group,\n    hidden: hidden,\n    list: list,\n    radio: radio,\n    select: select,\n    textarea: textarea,\n    text: text,\n    color: text,\n    date: text,\n    datetimeLocal: text,\n    email: text,\n    month: text,\n    number: text,\n    password: text,\n    search: text,\n    tel: text,\n    time: text,\n    url: text,\n    week: text,\n    range: text\n});\n\nexport { $attrs, $extend, $for, $if, $root, actions, box, boxHelp, boxLabel, boxOption, boxOptions, boxWrapper, button, buttonInput, buttonLabel, checkbox, checkboxes, text as color, composable, createLibraryPlugin, createSection, text as date, text as datetimeLocal, decorator, defaultIcon, disables as disablesChildren, text as email, extendSchema, fieldset, file, fileInput, fileItem, fileList, fileName, fileRemove, files, form, formInput, form$1 as forms, fragment, group, help, hidden, icon, ignore as ignores, initialValue, inner, index as inputs, isSchemaObject, isSlotCondition, label, legend, list, localize, message, messages, text as month, noFiles, normalizeBoxes, normalizeOptions, text as number, option, optionSlot, options, outer, text as password, prefix, radio, radios, text as range, text as search, select, selectInput$1 as selectInput, select$1 as selects, button as submit, submitInput, suffix, text as tel, text, textInput, textarea, textareaInput, text as time, text as url, useSchema, text as week, wrapper };\n"],
  "mappings": "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",
  "names": ["format", "use", "index", "receipts", "wrapper", "node", "bubble", "error", "messages", "message", "errors", "options", "message", "options", "calm", "hydrate", "setIndex", "index", "fragment", "errors", "message", "trap", "char", "depth", "token", "options", "option", "files", "file", "defaultIcon", "select", "text"]
}
