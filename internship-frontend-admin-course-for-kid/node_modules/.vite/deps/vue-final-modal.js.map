{
  "version": 3,
  "sources": ["../../vue-final-modal/lib/utils/focusTrap.js", "../../vue-final-modal/lib/utils/dragResize.js", "../../vue-final-modal/lib/utils/bodyScrollLock.js", "../../vue-final-modal/lib/VueFinalModal.vue", "../../vue-final-modal/lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js", "../../vue-final-modal/node_modules/style-inject/dist/style-inject.es.js", "../../vue-final-modal/lib/ModalsContainer.vue", "../../vue-final-modal/lib/ModalsContainer.vue?vue&type=template&id=74d49173&lang.js", "../../vue-final-modal/lib/PluginCore.js", "../../vue-final-modal/lib/Plugin.js", "dep:vue-final-modal"],
  "sourcesContent": ["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n", "export const setStyle = (el, key, value) => {\n  const cacheStyle = el.style[key]\n  el.style[key] = value\n  return () => {\n    el.style[key] = cacheStyle\n  }\n}\n\nexport const getPosition = e => {\n  const { clientX: x, clientY: y } = e.targetTouches ? e.targetTouches[0] : e\n  return { x, y }\n}\n\nexport const capitalize = s => {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport const clamp = (min, num, max) => {\n  if (typeof min !== 'number') {\n    min = Math.min(num, max) || num\n  }\n  if (typeof max !== 'number') {\n    max = Math.max(num, min)\n  }\n  return Math.min(Math.max(num, min), max)\n}\n\nexport const trimPx = distance => {\n  return (distance && Number(distance.replace(/px$/, ''))) || 0\n}\n\nexport const validDragElement = (e, el, dragSelector) => {\n  if (dragSelector === '') return true\n  const list = [...el.querySelectorAll(dragSelector)]\n  return list.includes(e.target)\n}\n\nconst pointerType = {\n  down: {\n    pc: 'mousedown',\n    m: 'touchstart'\n  },\n  move: {\n    pc: 'mousemove',\n    m: 'touchmove'\n  },\n  up: {\n    pc: 'mouseup',\n    m: 'touchend'\n  }\n}\nexport const addListener = (type, el, callback) => {\n  el && el.addEventListener(pointerType[type].pc, callback)\n  el && el.addEventListener(pointerType[type].m, callback, { passive: false })\n}\nexport const removeListener = (type, el, callback) => {\n  el && el.removeEventListener(pointerType[type].pc, callback)\n  el && el.removeEventListener(pointerType[type].m, callback)\n}\n", "// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\nimport { shallowReactive } from 'vue'\n\nexport function defineApi() {\n  let _modalComponent = null\n\n  return {\n    show(modal, ...args) {\n      switch (typeof modal) {\n        case 'string':\n          return this.toggle(modal, true, ...args)\n        case 'object': {\n          return Promise.allSettled([\n            new Promise((resolve, reject) => {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: _modalComponent,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0],\n                reject,\n                opened() {\n                  resolve('show')\n                }\n              }\n              this.dynamicModals.push(shallowReactive(Object.assign(defaultModal, modal)))\n            })\n          ])\n        }\n      }\n    },\n    hide(...names) {\n      return this.toggle(names, false)\n    },\n    hideAll() {\n      return this.hide(...this.openedModals.map(modal => modal.props.name))\n    },\n    toggle(name, ...args) {\n      const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n      return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n    },\n    get(...names) {\n      return this.modals.filter(modal => names.includes(modal.props.name))\n    },\n    dynamicModals: shallowReactive([]),\n    openedModals: [],\n    modals: [],\n    _setDefaultModal(modalComponent) {\n      _modalComponent = modalComponent\n    }\n  }\n}\n\nfunction bindApi(component, api) {\n  const _component = { ...component, props: { ...component.props } }\n  Object.assign(_component.props, {\n    api: { type: Object, default: () => api }\n  })\n  return _component\n}\n\nexport function defineModal(api) {\n  const modalComponent = bindApi(VueFinalModal, api)\n  api._setDefaultModal(modalComponent)\n  return modalComponent\n}\n\nexport function defineContainer(api) {\n  return bindApi(ModalsContainer, api)\n}\n", "import { defineApi, defineModal, defineContainer } from './PluginCore'\n\n/**\n * @description Ensure that `_vfm` is used when function `installPlugin` is executed for the first time\n */\nlet _count = 0\n\nconst _key = '$vfm'\nconst _componentName = 'VueFinalModal'\nconst _dynamicContainerName = 'ModalsContainer'\n\n/**\n * @description Support create multiple vfm instance\n */\nexport const defineVfm = () => {\n  let api = defineApi()\n  return {\n    [_key]: api,\n    [_componentName]: defineModal(api),\n    [_dynamicContainerName]: defineContainer(api)\n  }\n}\n\n/**\n * @description Create a vfm instance by default for directly support `import { $vfm, VueFinalModal, ModalsContainer } from 'vue-final-modal'`\n */\nconst _vfm = defineVfm()\nexport const { $vfm, VueFinalModal, ModalsContainer } = _vfm\n\n/**\n * @description Register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nconst installVfm = (App, options = {}) => {\n  const { $vfm, VueFinalModal, ModalsContainer } = _count === 0 ? _vfm : defineVfm()\n  _count += 1\n  const key = options.key || _key\n  const componentName = options.componentName || _componentName\n  const dynamicContainerName = options.dynamicContainerName || _dynamicContainerName\n  Object.defineProperty(App.config.globalProperties, key, {\n    get() {\n      return $vfm\n    }\n  })\n  App.provide(key, $vfm)\n  App.component(componentName, VueFinalModal)\n  App.component(dynamicContainerName, ModalsContainer)\n}\n\n/**\n * @description Vue plugin for register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nexport const vfmPlugin = pluginOptions => ({\n  install(App, options) {\n    const _options = Object.assign({}, pluginOptions, options)\n    installVfm(App, _options)\n  }\n})\n\nvfmPlugin.install = installVfm\n", "import d from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\";export default d;\nexport * from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\""],
  "mappings": "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",
  "names": ["queryFocusableElements", "element", "selector", "querySelectorAll", "isFocused", "document", "activeElement", "FocusTrap", "root", "elements", "onKeyDown", "this", "bind", "enable", "disable", "firstElement", "lastElement", "length", "event", "key", "keyCode", "shiftKey", "focus", "preventDefault", "addEventListener", "removeEventListener", "getPosition", "e", "targetTouches", "x", "clientX", "y", "clientY", "clamp", "min", "num", "max", "Math", "trimPx", "distance", "Number", "replace", "pointerType", "down", "pc", "m", "move", "up", "addListener", "type", "el", "callback", "passive", "removeListener", "hasPassiveEvents", "window", "passiveTestOptions", "previousBodyOverflowSetting", "previousBodyPaddingRight", "isIosDevice", "navigator", "platform", "test", "maxTouchPoints", "locks", "documentListenerAdded", "initialClientY", "hasAnyScrollableEl", "delta", "path", "push", "classList", "contains", "parentElement", "forEach", "nodeType", "Node", "ELEMENT_NODE", "style", "getComputedStyle", "includes", "overflowY", "scrollHeight", "clientHeight", "scrollTop", "allowTouchMove", "some", "rawEvent", "target", "touches", "disableBodyScroll", "targetElement", "options", "lock", "ontouchstart", "ontouchmove", "stopPropagation", "undefined", "reserveScrollBarGap", "scrollBarGap", "innerWidth", "documentElement", "clientWidth", "computedBodyPaddingRight", "parseInt", "body", "getPropertyValue", "paddingRight", "overflow", "console", "error", "enableBodyScroll", "filter", "noop", "TransitionState", "resizeCursor", "t", "tr", "r", "br", "b", "bl", "l", "tl", "props", "name", "String", "modelValue", "Boolean", "ssr", "classes", "Object", "Array", "overlayClass", "contentClass", "styles", "overlayStyle", "contentStyle", "lockScroll", "hideOverlay", "clickToClose", "escToClose", "preventClick", "attach", "validator", "val", "transition", "overlayTransition", "keepOverlay", "zIndexAuto", "zIndexBase", "zIndex", "focusRetain", "focusTrap", "fitParent", "drag", "dragSelector", "keepChangedStyle", "resize", "resizeDirections", "value", "indexOf", "minWidth", "minHeight", "maxWidth", "Infinity", "maxHeight", "emits", "setup", "emit", "uid", "Symbol", "ref", "vfmContainer", "vfmContent", "vfmResize", "vfmOverlayTransition", "vfmTransition", "modalStackIndex", "$focusTrap", "visible", "visibility", "reactive", "modal", "overlay", "overlayTransitionState", "modalTransitionState", "_stopEvent", "params", "dragResizeStyle", "_state", "lastMousedownEl", "resolveToggle", "rejectToggle", "computedOverlayTransition", "computed", "computedTransition", "isComponentReadyToBeDestroyed", "calculateZIndex", "bindStyle", "bindContentStyle", "isArray", "getModalInfo", "getAttachElement", "handleLockScroll", "toggle", "mounted", "createModalEvent", "emitEvent", "nextTick", "appendChild", "index", "api", "openedModals", "findIndex", "vm", "splice", "warn", "concat", "close", "$_vm", "removeDragDown", "removeResizeDown", "querySelector", "eventProps", "eventType", "stopEvent", "stop", "emitState", "state", "action", "show", "_params", "Promise", "resolve", "reject", "res", "err", "arguments", "pointerDown", "STATE_RESIZE", "STATE_DRAG", "direction", "getAttribute", "cacheStyle", "rectContainer", "getBoundingClientRect", "rectContent", "isAbsolute", "position", "top", "left", "limit", "absolute", "minTop", "minLeft", "maxTop", "height", "maxLeft", "width", "relative", "bottom", "right", "resetBodyCursor", "moving", "offset", "setOffset", "dir", "offsetAxis", "axis", "edge", "minEdge", "getEdge", "maxEdge", "getOffsetAxis", "edgeName", "getDirectionInfo", "isPositive", "s", "rectContentEdge", "positionOffset", "EdgeName", "charAt", "toUpperCase", "slice", "directions", "_offset", "split", "directionInfo", "margin", "touchAction", "transform", "end", "setTimeout", "addDragDown", "addResizeDown", "watch", "display", "flush", "modals", "onMounted", "onBeforeUnmount", "remove", "beforeOverlayEnter", "afterOverlayEnter", "beforeOverlayLeave", "afterOverlayLeave", "beforeModalEnter", "afterModalEnter", "beforeModalLeave", "enabled", "afterModalLeave", "onMousedown", "onMouseupContainer", "onEsc", "$props", "$setup", "_createBlock", "onKeydown", "_createVNode", "_mergeProps", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave", "toString", "role", "tabindex", "onMouseup", "_renderSlot", "_ctx", "_hoisted_1", "css", "insertAt", "head", "getElementsByTagName", "createElement", "firstChild", "insertBefore", "styleSheet", "cssText", "createTextNode", "methods", "dynamicModals", "beforeOpen", "_this", "$nextTick", "n", "isString", "bindApi", "component", "_component", "assign", "id", "_toHandlers", "on", "on_closed", "$options", "on_beforeOpen", "on_opened", "opened", "slots", "slot", "_createCommentVNode", "innerHTML", "_count", "defineVfm", "_modalComponent", "args", "allSettled", "defaultModal", "shallowReactive", "hide", "names", "hideAll", "map", "get", "_setDefaultModal", "modalComponent", "VueFinalModal", "ModalsContainer", "_vfm", "$vfm", "installVfm", "App", "componentName", "dynamicContainerName", "defineProperty", "config", "globalProperties", "provide", "vfmPlugin", "pluginOptions", "install", "_options"]
}
