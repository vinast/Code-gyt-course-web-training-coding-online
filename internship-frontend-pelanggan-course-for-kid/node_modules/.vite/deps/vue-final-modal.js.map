{
  "version": 3,
  "sources": ["../../vue-final-modal/lib/utils/focusTrap.js", "../../vue-final-modal/lib/utils/dragResize.js", "../../vue-final-modal/lib/utils/bodyScrollLock.js", "../../vue-final-modal/lib/VueFinalModal.vue", "../../vue-final-modal/lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js", "../../vue-final-modal/node_modules/style-inject/dist/style-inject.es.js", "../../vue-final-modal/lib/ModalsContainer.vue", "../../vue-final-modal/lib/ModalsContainer.vue?vue&type=template&id=74d49173&lang.js", "../../vue-final-modal/lib/PluginCore.js", "../../vue-final-modal/lib/Plugin.js", "dep:vue-final-modal"],
  "sourcesContent": ["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n", "export const setStyle = (el, key, value) => {\n  const cacheStyle = el.style[key]\n  el.style[key] = value\n  return () => {\n    el.style[key] = cacheStyle\n  }\n}\n\nexport const getPosition = e => {\n  const { clientX: x, clientY: y } = e.targetTouches ? e.targetTouches[0] : e\n  return { x, y }\n}\n\nexport const capitalize = s => {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport const clamp = (min, num, max) => {\n  if (typeof min !== 'number') {\n    min = Math.min(num, max) || num\n  }\n  if (typeof max !== 'number') {\n    max = Math.max(num, min)\n  }\n  return Math.min(Math.max(num, min), max)\n}\n\nexport const trimPx = distance => {\n  return (distance && Number(distance.replace(/px$/, ''))) || 0\n}\n\nexport const validDragElement = (e, el, dragSelector) => {\n  if (dragSelector === '') return true\n  const list = [...el.querySelectorAll(dragSelector)]\n  return list.includes(e.target)\n}\n\nconst pointerType = {\n  down: {\n    pc: 'mousedown',\n    m: 'touchstart'\n  },\n  move: {\n    pc: 'mousemove',\n    m: 'touchmove'\n  },\n  up: {\n    pc: 'mouseup',\n    m: 'touchend'\n  }\n}\nexport const addListener = (type, el, callback) => {\n  el && el.addEventListener(pointerType[type].pc, callback)\n  el && el.addEventListener(pointerType[type].m, callback, { passive: false })\n}\nexport const removeListener = (type, el, callback) => {\n  el && el.removeEventListener(pointerType[type].pc, callback)\n  el && el.removeEventListener(pointerType[type].m, callback)\n}\n", "// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    onMounted(() => {\n      props.api.modals.push(getModalInfo())\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    onMounted(() => {\n      props.api.modals.push(getModalInfo())\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n", "function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n", "import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\nimport { shallowReactive } from 'vue'\n\nexport function defineApi() {\n  let _modalComponent = null\n\n  return {\n    show(modal, ...args) {\n      switch (typeof modal) {\n        case 'string':\n          return this.toggle(modal, true, ...args)\n        case 'object': {\n          return Promise.allSettled([\n            new Promise((resolve, reject) => {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: _modalComponent,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0],\n                reject,\n                opened() {\n                  resolve('show')\n                }\n              }\n              this.dynamicModals.push(shallowReactive(Object.assign(defaultModal, modal)))\n            })\n          ])\n        }\n      }\n    },\n    hide(...names) {\n      return this.toggle(names, false)\n    },\n    hideAll() {\n      return this.hide(...this.openedModals.map(modal => modal.props.name))\n    },\n    toggle(name, ...args) {\n      const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n      return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n    },\n    get(...names) {\n      return this.modals.filter(modal => names.includes(modal.props.name))\n    },\n    dynamicModals: shallowReactive([]),\n    openedModals: [],\n    modals: [],\n    _setDefaultModal(modalComponent) {\n      _modalComponent = modalComponent\n    }\n  }\n}\n\nfunction bindApi(component, api) {\n  const _component = { ...component, props: { ...component.props } }\n  Object.assign(_component.props, {\n    api: { type: Object, default: () => api }\n  })\n  return _component\n}\n\nexport function defineModal(api) {\n  const modalComponent = bindApi(VueFinalModal, api)\n  api._setDefaultModal(modalComponent)\n  return modalComponent\n}\n\nexport function defineContainer(api) {\n  return bindApi(ModalsContainer, api)\n}\n", "import { defineApi, defineModal, defineContainer } from './PluginCore'\n\n/**\n * @description Ensure that `_vfm` is used when function `installPlugin` is executed for the first time\n */\nlet _count = 0\n\nconst _key = '$vfm'\nconst _componentName = 'VueFinalModal'\nconst _dynamicContainerName = 'ModalsContainer'\n\n/**\n * @description Support create multiple vfm instance\n */\nexport const defineVfm = () => {\n  let api = defineApi()\n  return {\n    [_key]: api,\n    [_componentName]: defineModal(api),\n    [_dynamicContainerName]: defineContainer(api)\n  }\n}\n\n/**\n * @description Create a vfm instance by default for directly support `import { $vfm, VueFinalModal, ModalsContainer } from 'vue-final-modal'`\n */\nconst _vfm = defineVfm()\nexport const { $vfm, VueFinalModal, ModalsContainer } = _vfm\n\n/**\n * @description Register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nconst installVfm = (App, options = {}) => {\n  const { $vfm, VueFinalModal, ModalsContainer } = _count === 0 ? _vfm : defineVfm()\n  _count += 1\n  const key = options.key || _key\n  const componentName = options.componentName || _componentName\n  const dynamicContainerName = options.dynamicContainerName || _dynamicContainerName\n  Object.defineProperty(App.config.globalProperties, key, {\n    get() {\n      return $vfm\n    }\n  })\n  App.provide(key, $vfm)\n  App.component(componentName, VueFinalModal)\n  App.component(dynamicContainerName, ModalsContainer)\n}\n\n/**\n * @description Vue plugin for register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nexport const vfmPlugin = pluginOptions => ({\n  install(App, options) {\n    const _options = Object.assign({}, pluginOptions, options)\n    installVfm(App, _options)\n  }\n})\n\nvfmPlugin.install = installVfm\n", "import d from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\";export default d;\nexport * from \"./node_modules/vue-final-modal/dist/VueFinalModal.esm.js\""],
  "mappings": "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",
  "names": ["FOCUSABLE_ELEMENTS_QUERY", "isTabPressed", "event", "key", "keyCode", "querySelectorAll", "element", "selector", "queryFocusableElements", "isFocused", "document", "activeElement", "isNothingFocused", "FocusTrap", "root", "elements", "onKeyDown", "bind", "enable", "disable", "firstElement", "lastElement", "length", "shiftKey", "focus", "preventDefault", "addEventListener", "removeEventListener", "setStyle", "el", "value", "cacheStyle", "style", "getPosition", "e", "targetTouches", "x", "clientX", "y", "clientY", "capitalize", "s", "charAt", "toUpperCase", "slice", "clamp", "min", "num", "max", "Math", "trimPx", "distance", "Number", "replace", "validDragElement", "dragSelector", "list", "includes", "target", "pointerType", "down", "pc", "m", "move", "up", "addListener", "type", "callback", "passive", "removeListener", "hasPassiveEvents", "window", "passiveTestOptions", "undefined", "isIosDevice", "navigator", "platform", "test", "maxTouchPoints", "locks", "documentListenerAdded", "initialClientY", "previousBodyOverflowSetting", "previousBodyPaddingRight", "hasScrollbar", "nodeType", "Node", "ELEMENT_NODE", "getComputedStyle", "overflowY", "scrollHeight", "clientHeight", "shouldScroll", "delta", "scrollTop", "composedPath", "path", "push", "classList", "contains", "parentElement", "hasAnyScrollableEl", "forEach", "allowTouchMove", "some", "rawEvent", "touches", "setOverflowHidden", "options", "reserveScrollBarGap", "scrollBarGap", "innerWidth", "documentElement", "clientWidth", "computedBodyPaddingRight", "parseInt", "body", "getPropertyValue", "paddingRight", "overflow", "restoreOverflowSetting", "isTargetElementTotallyScrolled", "targetElement", "handleScroll", "stopPropagation", "disableBodyScroll", "console", "error", "lock", "ontouchstart", "ontouchmove", "enableBodyScroll", "filter", "noop", "TransitionState", "Enter", "Entering", "Leave", "Leaving", "resizeCursor", "t", "tr", "r", "br", "b", "bl", "l", "tl", "props", "name", "String", "modelValue", "Boolean", "ssr", "classes", "Object", "Array", "overlayClass", "contentClass", "styles", "overlayStyle", "_default", "contentStyle", "lockScroll", "hideOverlay", "clickToClose", "escToClose", "preventClick", "attach", "validator", "val", "transition", "overlayTransition", "keepOverlay", "zIndexAuto", "zIndexBase", "zIndex", "focusRetain", "focusTrap", "fitParent", "drag", "keepChangedStyle", "resize", "resizeDirections", "indexOf", "minWidth", "minHeight", "maxWidth", "Infinity", "maxHeight", "emits", "setup", "emit", "uid", "Symbol", "ref", "vfmContainer", "vfmContent", "vfmResize", "vfmOverlayTransition", "vfmTransition", "modalStackIndex", "$focusTrap", "visible", "visibility", "reactive", "modal", "overlay", "overlayTransitionState", "modalTransitionState", "_stopEvent", "params", "dragResizeStyle", "_state", "lastMousedownEl", "resolveToggle", "rejectToggle", "computedOverlayTransition", "computed", "computedTransition", "isComponentReadyToBeDestroyed", "calculateZIndex", "bindStyle", "bindContentStyle", "isArray", "watch", "mounted", "emitEvent", "close", "handleLockScroll", "display", "flush", "addDragDown", "removeDragDown", "addResizeDown", "removeResizeDown", "onMounted", "api", "modals", "getModalInfo", "onBeforeUnmount", "remove", "index", "findIndex", "vm", "splice", "getAttachElement", "toggle", "createModalEvent", "appendChild", "nextTick", "openedModals", "startTransitionEnter", "warn", "concat", "$_vm", "startTransitionLeave", "querySelector", "beforeOverlayEnter", "afterOverlayEnter", "beforeOverlayLeave", "afterOverlayLeave", "beforeModalEnter", "afterModalEnter", "beforeModalLeave", "enabled", "afterModalLeave", "stopEvent", "stop", "onMousedown", "onMouseupContainer", "onEsc", "eventProps", "eventType", "emitState", "state", "action", "show", "_params", "Promise", "resolve", "reject", "res", "err", "arguments", "pointerDown", "STATE_RESIZE", "STATE_DRAG", "direction", "getAttribute", "rectContainer", "getBoundingClientRect", "rectContent", "isAbsolute", "position", "top", "left", "limit", "absolute", "minTop", "minLeft", "maxTop", "height", "maxLeft", "width", "relative", "bottom", "right", "resetBodyCursor", "moving", "offset", "getResizeOffset", "margin", "touchAction", "transform", "end", "setTimeout", "setOffset", "dir", "offsetAxis", "axis", "edge", "minEdge", "getEdge", "maxEdge", "getOffsetAxis", "edgeName", "getDirectionInfo", "isPositive", "rectContentEdge", "positionOffset", "EdgeName", "directions", "_offset", "split", "directionInfo", "$props", "$setup", "_createBlock", "onKeydown", "_createVNode", "_mergeProps", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave", "toString", "role", "tabindex", "onMouseup", "_renderSlot", "_ctx", "_hoisted_1", "styleInject", "css", "insertAt", "head", "getElementsByTagName", "createElement", "firstChild", "insertBefore", "styleSheet", "cssText", "createTextNode", "methods", "dynamicModals", "beforeOpen", "$nextTick", "isString", "component", "id", "_toHandlers", "on", "on_closed", "$options", "on_beforeOpen", "on_opened", "opened", "slots", "slot", "_createCommentVNode", "innerHTML", "defineApi", "_modalComponent", "args", "_key", "allSettled", "defaultModal", "shallowReactive", "assign", "hide", "names", "hideAll", "map", "get", "_setDefaultModal", "modalComponent", "bindApi", "_component", "defineModal", "VueFinalModal", "defineContainer", "ModalsContainer", "_count", "_componentName", "_dynamicContainerName", "defineVfm", "_vfm", "$vfm", "installVfm", "App", "componentName", "dynamicContainerName", "defineProperty", "config", "globalProperties", "provide", "vfmPlugin", "pluginOptions", "install", "_options"]
}
